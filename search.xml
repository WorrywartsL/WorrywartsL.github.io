<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>离散化(Discretization)</title>
      <link href="/2021/07/12/%E7%A6%BB%E6%95%A3%E5%8C%96(Discretization)/"/>
      <url>/2021/07/12/%E7%A6%BB%E6%95%A3%E5%8C%96(Discretization)/</url>
      
        <content type="html"><![CDATA[<h2 id="简介-Introduction"><a href="#简介-Introduction" class="headerlink" title="简介(Introduction)"></a>简介(Introduction)</h2><blockquote><blockquote><p>离散化，把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。<br>通俗的说，离散化是在不改变数据相对大小的条件下，对数据进行相应的缩小。</p></blockquote></blockquote><h2 id="描述-Description"><a href="#描述-Description" class="headerlink" title="描述(Description)"></a>描述(Description)</h2><p>离散化用于处理一些个数不多，但是数据本身很大但是仍需要作为数组等无法过大的下标时，我们可以处理一下这些大的下标，并且依然保持其原序。</p><h2 id="示例-Example"><a href="#示例-Example" class="headerlink" title="示例(Example)"></a>示例(Example)</h2><p><img src="https://i.loli.net/2021/07/12/hxvcRIXkzZAB96f.jpg" alt="位运算示例"></p><p>然而这个示例好像并没有什么用诶。</p><h2 id="细节-Detail"><a href="#细节-Detail" class="headerlink" title="细节(Detail)"></a>细节(Detail)</h2><ol><li>注意去重复元素。</li><li>如何快速保序映射？</li></ol><h2 id="代码实现-Code"><a href="#代码实现-Code" class="headerlink" title="代码实现(Code)"></a>代码实现(Code)</h2><p>首先来完成去重操作:</p><pre><code class="line-numbers language-cpp"># include &lt;algorithm&gt;sort(a.begin(),a.end());//首先排序://然后去重a.erase(unique(a.begin(),a.end()),a.end());</code></pre><p>第一步完成了，那么第二步快速映射也很轻松有二分查找：</p><pre><code class="line-numbers language-cpp">int find(int x)&#123;  int l = 0 , r = a.size() -1;  while(l &lt; r)  &#123;    int mid = l + r &gt;&gt;1;    if(a[mid] &gt;= x)r = mid;    else l = mid + 1;  &#125;  return l +1;//从1~n的映射。&#125;</code></pre><hr><h2 id="应用：区间和"><a href="#应用：区间和" class="headerlink" title="应用：区间和"></a>应用：区间和</h2><blockquote><blockquote><p>假定有一个无限长的数轴，数轴上每个坐标上的数都是0。<br>现在，我们首先进行 n 次操作，每次操作将某一位置x上的数加c。<br>接下来，进行 m 次询问，每个询问包含两个整数l和r，你需要求出在区间[l, r]之间的所有数的和。<br><strong>输入格式</strong><br>第一行包含两个整数n和m。<br>接下来 n 行，每行包含两个整数x和c。<br>再接下里 m 行，每行包含两个整数l和r。<br><strong>输出格式</strong><br>共m行，每行输出一个询问中所求的区间内数字和。<br><strong>数据范围</strong><br>$-10^9≤x≤10^9$,<br>$1≤n,m≤10^5$,<br>$−10^9≤l≤r≤10^9$,<br>$−10000≤c≤10000$<br>输入样例：<br>3 3<br>1 2<br>3 6<br>7 5<br>1 3<br>4 6<br>7 8<br>输出样例：<br>8<br>0<br>5</p></blockquote></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>由于坐标数据范围很大，但是数据量较小，考虑离散化处理所有坐标。<br>最后要求区间和，可以使用前缀和来求。</p><hr><p>离散化虽然简单，却是比较实用的一种方法。</p>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 离散化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算(Bitwise operation)</title>
      <link href="/2021/07/12/%E4%BD%8D%E8%BF%90%E7%AE%97(Bitwise%20operation)/"/>
      <url>/2021/07/12/%E4%BD%8D%E8%BF%90%E7%AE%97(Bitwise%20operation)/</url>
      
        <content type="html"><![CDATA[<h2 id="简介-Introduction"><a href="#简介-Introduction" class="headerlink" title="简介(Introduction)"></a>简介(Introduction)</h2><blockquote><blockquote><p>程序中的所有数在计算机内存中都是以二进制的形式储存的。位运算就是直接对整数在内存中的二进制位进行操作。</p></blockquote></blockquote><h2 id="描述-Description"><a href="#描述-Description" class="headerlink" title="描述(Description)"></a>描述(Description)</h2><p>位运算是计算机内的一种最基本的运算方式，快捷高效。又是一个小知识点。运算的逻辑是先将两个操作数转化成二进制数，然后做位运算。</p><table><thead><tr><th align="left">运算符</th><th align="left">名称</th></tr></thead><tbody><tr><td align="left">&amp;</td><td align="left">按位“与”</td></tr><tr><td align="left">丨</td><td align="left">按位“或”</td></tr><tr><td align="left">^</td><td align="left">按位“异或”</td></tr><tr><td align="left">~</td><td align="left">取反</td></tr><tr><td align="left">&lt;&lt;</td><td align="left">左移</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">右移</td></tr></tbody></table><p>具体运算规律如下：</p><h2 id="示例-Example"><a href="#示例-Example" class="headerlink" title="示例(Example)"></a>示例(Example)</h2><table><thead><tr><th align="left">A</th><th align="left">B</th><th align="left">~A</th><th align="left">A丨B</th><th align="left">A&amp;B</th><th align="left">A^B</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">0</td></tr><tr><td align="left">对于&lt;&lt;和&gt;&gt;运算，在数据可以表达的范围内，a&lt;&lt;k相当于$a×2^k$，而a&gt;&gt;k相当于$a / 2^k$。</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><h2 id="细节-Detail"><a href="#细节-Detail" class="headerlink" title="细节(Detail)"></a>细节(Detail)</h2><ol><li>位运算的操作对象只能是整型或者字符型数据。</li><li>操作数的位移运算不改变原数的值。</li></ol><hr><h2 id="应用：二进制中1的个数"><a href="#应用：二进制中1的个数" class="headerlink" title="应用：二进制中1的个数"></a>应用：二进制中1的个数</h2><p>（重点当然是记住简约而不简单的应用啦)</p><blockquote><blockquote><p>给定一个长度为n的数列，请你求出数列中每个数的二进制表示中1的个数。<br><strong>输入格式</strong><br>第一行包含整数n。<br>第二行包含n个整数，表示整个数列。<br><strong>输出格式</strong><br>共一行，包含n个整数，其中的第 i 个数表示数列中的第 i 个数的二进制表示中1的个数。<br><strong>数据范围</strong><br>$1≤n≤100000$,<br>$0≤数列中元素的值≤10^9$<br><strong>输入样例：</strong><br>5<br>1 2 3 4 5<br><strong>输出样例：</strong><br>1 1 2 1 2  </p></blockquote></blockquote><p>先来看一个祖传操作：lowbit</p><pre><code class="line-numbers language-cpp">int lowbit(x)&#123;  return x &amp; -x;&#125;</code></pre><p>该函数返回x二进制下最后一位1的位置对应的值。(这么说可能不太明白，上图吧。)</p><h2 id="示例-Example-1"><a href="#示例-Example-1" class="headerlink" title="示例(Example)"></a>示例(Example)</h2><p><img src="https://i.loli.net/2021/07/12/3DrIvT6MQWEmOqF.jpg" alt="位运算示例"></p><p>有了这样一个神奇的操作后这题也就解决了大半。<br>再附上一个本题的另一小半核心代码：</p><pre><code class="line-numbers language-cpp">while(x)x - lowbit(x),res++;</code></pre><p>这样本题也就解决啦~</p><p>当然还有一个简单的操作也可以记一下：求n的第k位二进制数字:</p><pre><code class="line-numbers language-cpp">int findk(int n , int k)&#123;  return n &gt;&gt; k &amp; 1;&#125;</code></pre><hr><p>位运算为之后的状压准备，lowbit为后面的树状数组做准备。</p>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针算法</title>
      <link href="/2021/07/12/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/"/>
      <url>/2021/07/12/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="简介-Introduction"><a href="#简介-Introduction" class="headerlink" title="简介(Introduction)"></a>简介(Introduction)</h2><blockquote><blockquote><p>双指针算法是一种广泛运用的基础算法,在很多地方都有应用。<strong>其核心用处是对于朴素的算法做优化。</strong></p></blockquote></blockquote><h2 id="描述-Description"><a href="#描述-Description" class="headerlink" title="描述(Description)"></a>描述(Description)</h2><p>双指针算法在很多地方都有应用，只是很多时候我们没有意识到自己正在用。如快速排序、归并排序中都用到了双指针算法。</p><h2 id="代码实现-Code"><a href="#代码实现-Code" class="headerlink" title="代码实现(Code)"></a>代码实现(Code)</h2><p>双指针算法与其说是一种算法，不如说是一种处理问题的方式，要具体问题具体分析。所以代码实现并不是那么重要。</p><pre><code class="line-numbers language-cpp">for(int i = 0 ; j= 0 ; i &lt; n ; i ++)&#123;  while(j &lt; i &amp;&amp; check(i,j))j++;  //具体的题目具体分析&#125;</code></pre><hr><h2 id="应用：最长连续不重复子序列"><a href="#应用：最长连续不重复子序列" class="headerlink" title="应用：最长连续不重复子序列"></a>应用：最长连续不重复子序列</h2><blockquote><blockquote><p>给定一个长度为n的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。<br><strong>输入格式</strong><br>第一行包含整数n。<br>第二行包含n个整数（均在0~100000范围内），表示整数序列。<br><strong>输出格式</strong><br>共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。<br><strong>数据范围</strong><br>1≤n≤100000<br><strong>输入样例：</strong><br>5<br>1 2 2 3 5<br><strong>输出样例：</strong><br>3  </p></blockquote></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这题首先可以想到一个朴素的做法：利用两重for循环暴力求解，其时间复杂度为$O(n^2)$。<br>考虑单调性优化：前后指针的移动是有相互关联的。当前后指针分别指向当前位置的<strong>最长不重复段</strong>，前指针向后移动时，后指针也一定会向后移动。这样时间复杂度就可以优化为$O(n)$。</p><h2 id="核心代码-Code"><a href="#核心代码-Code" class="headerlink" title="核心代码(Code)"></a>核心代码(Code)</h2><pre><code class="line-numbers language-cpp">for(int i = 0 , j = 0 ; i &lt; n ; i++)//循环i&#123;  s[a[i]]++;//前指针做记录  while(s[a[i]] &gt; 1)//大于1说明出现重复  &#123;    s[a[j]]--;//去掉重复，知道条件不成立    j++;  &#125;  res = max(res, i - j + 1);//取最长不重复区间长。&#125;</code></pre><h2 id="示例-Example"><a href="#示例-Example" class="headerlink" title="示例(Example)"></a>示例(Example)</h2><h2 id><a href="#" class="headerlink" title></a><img src="https://i.loli.net/2021/07/12/aOVuwkNEL91grhq.jpg" alt="演示双指针"></h2><hr><p>双指针就这样水过去吧！这种还是得多做题。</p>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>差分(Adjacent_difference)</title>
      <link href="/2021/07/11/%E5%B7%AE%E5%88%86(Adjacent_difference)/"/>
      <url>/2021/07/11/%E5%B7%AE%E5%88%86(Adjacent_difference)/</url>
      
        <content type="html"><![CDATA[<h2 id="简介-Introduction"><a href="#简介-Introduction" class="headerlink" title="简介(Introduction)"></a>简介(Introduction)</h2><blockquote><blockquote><p>差分与前缀和相对，可以视为前缀和的逆运算。差分它可以维护多次对序列的一个区间修改一个数。</p></blockquote></blockquote><h2 id="一维差分示例-Example"><a href="#一维差分示例-Example" class="headerlink" title="一维差分示例(Example)"></a>一维差分示例(Example)</h2><p>数列：</p><blockquote><p>$\begin{matrix} 2&amp;3&amp;5&amp;7&amp;11&amp;13&amp;17&amp;19\end{matrix}$</p></blockquote><p>差分处理之后：</p><blockquote><p>$\begin{matrix} 2&amp;1&amp;2&amp;2&amp;4&amp;2&amp;4&amp;2\end{matrix}$</p></blockquote><p>可以看到，差分后的数列用前缀和处理后可以得到：</p><blockquote><p>$\begin{matrix} 2&amp;3&amp;5&amp;7&amp;11&amp;13&amp;17&amp;19\end{matrix}$</p></blockquote><p>即为原数列。<br>通常情况下我们也并不关心差分后的结果，只关心差分并处理最后再前缀和后的结果。</p><h2 id="代码实现-Code"><a href="#代码实现-Code" class="headerlink" title="代码实现(Code)"></a>代码实现(Code)</h2><pre><code class="line-numbers language-cpp">void adjdif(int a[], int b[],int n)&#123;  for(int i = 1; i &lt;= n ;i++)  b[i] = a[i] - a[i -1];&#125;</code></pre><p>和前缀和对应的，c++标准库中也实现了差分函数：</p><pre><code class="line-numbers language-cpp"># include &lt;numeric&gt;std::adjacent_difference(a, a + n, b);</code></pre><p>利用差分后再做前缀和可以得到原数列的性质，可以通过改变差分后的数组从而改变原数组。</p><pre><code class="line-numbers language-cpp">void Insert(int b[], int c)&#123;  b[1] += c;&#125;</code></pre><p>该函数使差分数组的第一个元素加上了常数$c$,可以想到，在做前缀和处理，回到原数组的时候，由递推公式为：$a[i] = a[i -1] + b[i];$，可以得到原数组所有的元素都将加上$c$。<br>再通过这个性质，做一点变形，有：</p><pre><code class="line-numbers language-cpp">void Insert(int b[],int l ,int r, int c)&#123;//l在r的左边(或重合)  b[l] += c;  b[r + 1] -=c;&#125;</code></pre><p>不难理解，该函数可以将原数组$[l,r]$部分的每个元素都加上常数$c$。    </p><p>基于此，我们甚至可以使用全初始化为0的数组来初始化原数组。只要把区间$[l,r]$缩小到每一个元素(l和r重合时)，根据<strong>函数可以将原数组$[l,r]$部分每个元素都加上c</strong>可以将一个元素赋予要赋的值。</p><p>所以所有的操作可以直接从差分数组本身开始，而不必用原数组做差分后操作，最后再前缀和。</p><h2 id="二维差分示例-Example"><a href="#二维差分示例-Example" class="headerlink" title="二维差分示例(Example)"></a>二维差分示例(Example)</h2><p>通过一维前缀和的启发，我们知道第一个差分操作是不必要的。初始化与修改都可以在差分数组中得到。二维也同理。<br>只要有类似的$Insert$函数即可。这里先给出代码，后给出解释。</p><h2 id="实现代码-Code"><a href="#实现代码-Code" class="headerlink" title="实现代码(Code)"></a>实现代码(Code)</h2><pre><code class="line-numbers language-cpp">void Insert(int x1, int x2, int y1, int y2, int c)&#123;//点(x1,y1) 在 (x2,y2)的左上方(或重合)  b[x1][y1] +=c;  b[x2 + 1][y2] -= c;  b[x2][y2 + 1] -= c;  b[x2][y2] +=c;&#125;</code></pre><h2 id="示例-Example"><a href="#示例-Example" class="headerlink" title="示例(Example)"></a>示例(Example)</h2><p><img src="https://i.loli.net/2021/07/11/YQJo1jGzCyStwE2.jpg" alt="二维差分示例"></p><p>由图不难得到代码中的操作公式~</p><hr><p>以上是一维、二维差分的板子，记下就行啦~<br>同样的，高维的和树相关的暂时还没学。</p>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 差分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和</title>
      <link href="/2021/07/11/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
      <url>/2021/07/11/%E5%89%8D%E7%BC%80%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="简介-Introduction"><a href="#简介-Introduction" class="headerlink" title="简介(Introduction)"></a>简介(Introduction)</h2><blockquote><blockquote><p>前缀和是一种常用的、较为高效的预处理方式。能够有效降低查询的时间复杂度。前缀和可以理解为数组前$n$项的和。</p></blockquote></blockquote><h2 id="一维前缀和示例-Example"><a href="#一维前缀和示例-Example" class="headerlink" title="一维前缀和示例(Example)"></a>一维前缀和示例(Example)</h2><blockquote><p>数列：$\begin{matrix} 1&amp;2&amp;3&amp;4&amp;5 \end{matrix}$<br>前缀和处理后：$\begin{matrix}1&amp;3&amp;6&amp;10&amp;15\end{matrix}$</p></blockquote><h2 id="代码实现-Code"><a href="#代码实现-Code" class="headerlink" title="代码实现(Code)"></a>代码实现(Code)</h2><pre><code class="line-numbers language-cpp">void presum1(int a[],int s[],int n)&#123;  for(int i = 1; i&lt;= n ; i++)//为了不特判第一个元素，一般定义i从1开始，0号元素为0  s[i] = s[i -1] + a[i];&#125;</code></pre><p>在C++标准库中也实现了前缀和函数：</p><pre><code class="line-numbers language-cpp"># include &lt;numeric&gt;std::partial_sum(a, a + n, s);</code></pre><h2 id="二维前缀和示例-Example"><a href="#二维前缀和示例-Example" class="headerlink" title="二维前缀和示例(Example)"></a>二维前缀和示例(Example)</h2><p>对于矩阵a，可以视为一个数组:</p><blockquote><p>$\begin{matrix}<br>1&amp;2&amp;4&amp;3\<br>5&amp;6&amp;2&amp;4\<br>6&amp;3&amp;5&amp;9\<br>\end{matrix}$ </p></blockquote><p> 其前缀和为：</p><blockquote><p>$\begin{matrix}<br>1&amp;3&amp;7&amp;10\<br>6&amp;14&amp;20&amp;27\<br>12&amp;23&amp;34&amp;50\<br>\end{matrix}$</p></blockquote><h2 id="代码实现-Code-1"><a href="#代码实现-Code-1" class="headerlink" title="代码实现(Code)"></a>代码实现(Code)</h2><pre><code class="line-numbers language-cpp">void presum2(int a[][],int s[][],int n, int m)&#123;  for(int i = 1; i &lt;= n; i++)    for(int j = 1; j &lt;= m; j++)      s[i][j] = s[i][j -1] +  s[i -1][j] - s[i- 1][j -1] + a[i][j];&#125;</code></pre><h2 id="分析-Analysis"><a href="#分析-Analysis" class="headerlink" title="分析(Analysis)"></a>分析(Analysis)</h2><p>经过预处理之后每次查询的时间复杂度为$O(1)$。<br>一维前缀和比较容易理解，每次用第$i$项更新前缀和数组即可。<br>而二维前缀和的处理是基于<em>容斥原理</em>的。这里并不多介绍容斥原理，仅仅以下面的示例做简单说明。</p><h2 id="示例-Example"><a href="#示例-Example" class="headerlink" title="示例(Example)"></a>示例(Example)</h2><p><img src="https://i.loli.net/2021/07/11/lQvNa3nysiGCgpe.jpg" alt="二维前缀和示例"></p><p>最后得到递推公式为：</p><blockquote><p>$s[i][j] = s[i-1][j] + s[i][j-1] - s[i -1][j -1] + a[i][j]$.</p></blockquote><hr><p>前缀和板子，记住就行啦~</p>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高精度(High Accuracy)</title>
      <link href="/2021/07/11/%E9%AB%98%E7%B2%BE%E5%BA%A6(High%20Accuracy)/"/>
      <url>/2021/07/11/%E9%AB%98%E7%B2%BE%E5%BA%A6(High%20Accuracy)/</url>
      
        <content type="html"><![CDATA[<h2 id="简介-Introduction"><a href="#简介-Introduction" class="headerlink" title="简介(Introduction)"></a>简介(Introduction)</h2><blockquote><blockquote><p>高精度算法（High Accuracy Algorithm）是处理大数字的数学计算方法。在一般的科学计算中，会经常算到小数点后几百位或者更多，当然也可能是几千亿几百亿的大数字。一般这类数字我们统称为高精度数，高精度算法是用计算机对于超大数据的一种模拟加，减，乘，除，乘方，阶乘，开方等运算。</p></blockquote></blockquote><h2 id="描述-Description"><a href="#描述-Description" class="headerlink" title="描述(Description)"></a>描述(Description)</h2><p>对于某些需要用到超级大的数运算的题目，可以利用高精度算法来解决。高精度的处理是把数字以字符的形式储存在数组中，并且利用四则运算的性质来进行加减乘除运算。</p><h2 id="代码实现-Code"><a href="#代码实现-Code" class="headerlink" title="代码实现(Code)"></a>代码实现(Code)</h2><h3 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h3><pre><code class="line-numbers language-cpp">vector&lt;int&gt; sum(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;  vector&lt;int&gt;C;//储存答案用  if(A.size() &lt; B.size())return sum(B,A);  //保证函数中的数组“A”是较大数  int t = 0;//用于储存进位值  for(int i = 0; i &lt; A.size(); i++)  &#123;    t += A[i];    if(B.size() &gt; i)t += B[i];    C.push_back(i % 10);//模拟进位    i /= 10;  &#125;  if(t)C.push_back(1);//如果最后t补位0，表明最高位进了一位。  return C;&#125;</code></pre><h3 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h3><pre><code class="line-numbers language-cpp">vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;//默认已经处理使得传入的A大于B  vector&lt;int&gt;C;  int t = 0;  for(int i = 0; i &lt;A.size(); i++)  &#123;    t = A[i] - t;    if(B.size() &gt; i)t-=B[i];    C.push_back((t + 10) % 10)//模拟借位    if(t &lt; 0)t = 1;//发生借位    else t = 0;  &#125;  while(C.size() &gt; 1 &amp;&amp; C.back() == 0)  C.pop_back();//去掉前导0;  return C;&#125;</code></pre><h3 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h3><pre><code class="line-numbers language-cpp">vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b)&#123;//常见的高精乘法是一个大数乘一个小数  vector&lt;int&gt;C;  int t = 0;  for(int i = 0; i &lt; A.size()||t;i++)  &#123;//要么i没有循环完，要么t 不为0    if(i &lt; A.size())t += a[i] * b;    C.push_back(t % 10);    t /= 10;  &#125;  while(C.size() &gt; 1 &amp;&amp; C.back() == 0)  C.pop_back();//去掉前导0  return C;&#125;</code></pre><h3 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h3><pre><code class="line-numbers language-cpp">vector&lt;int&gt; div(vector&lt;int&gt; &amp;A,int b ,int &amp;r)&#123;//除法除了会返回商，还会返回一个余数r  r = 0;  vector&lt;int&gt;C;  int t = 0;  for(int i = A.size()- 1; i &gt;= 0 ; i--)  &#123;//除法是从最高位开始计算的，与另三个不同    r = r * 10 + A[i];    C.psuh_back(r / b);    r %= b;  &#125;  reverse(C.begin(), C.end());//翻转一下去除前导0  while(C.size() &gt; 1 &amp;&amp; C.back() == 0)  C.pop_back();  return C;&#125;</code></pre><hr><p>都是些模板，记下就行了。</p>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高精度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找(Binary Search)</title>
      <link href="/2021/07/10/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE(Binary%20Search)/"/>
      <url>/2021/07/10/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE(Binary%20Search)/</url>
      
        <content type="html"><![CDATA[<h2 id="简介-Introduction"><a href="#简介-Introduction" class="headerlink" title="简介(Introduction)"></a>简介(Introduction)</h2><blockquote><blockquote><p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。</p></blockquote></blockquote><h2 id="描述-Description"><a href="#描述-Description" class="headerlink" title="描述(Description)"></a>描述(Description)</h2><p>二分查找的前提是目标已近排好序。二分查找每次取半查找保证其高效率。</p><h2 id="示例-Example"><a href="#示例-Example" class="headerlink" title="示例(Example)"></a>示例(Example)</h2><ol><li>二分查找下界</li></ol><p>在目标数组中找3： </p><p><img src="https://i.loli.net/2021/07/10/KgzGUhaVTLY9AtP.jpg" alt="示例1"></p><p>在目标数组中找4：</p><p><img src="https://i.loli.net/2021/07/10/YqfVMgGBbL1lQv8.jpg" alt="示例2"></p><p>可见当找不到目标值时，会找到一个合适的，可以插入目标值的位置的下标。</p><ol start="2"><li>二分查找上界</li></ol><p>在目标数组中找3：  </p><p><img src="https://i.loli.net/2021/07/10/1hYGFRV4p3zwaDg.jpg" alt="示例3"></p><p>同理，如果找不到目标值，也会找到一个合适的、目标值可插入的位置。<br>通过上面演示可以得到：无论问题如何，<strong>二分查找本身一定可以找到一个“答案”。</strong></p><h2 id="代码实现-Code-整数二分"><a href="#代码实现-Code-整数二分" class="headerlink" title="代码实现(Code)(整数二分)"></a>代码实现(Code)(整数二分)</h2><pre><code class="line-numbers language-cpp">//寻找下界：int lower(int a[], int l, int r, int v)&#123;  int mid;  while(l &lt; r)  &#123;    mid = (l + r) /2;    if(a[mid] &gt;= v) r = mid;    else l = mid + 1;  &#125;  return l;&#125;//寻找上界：int upper(int a[], int l, int r, int v)&#123;  int mid;  while(l &lt; r)  &#123;    mid = (l + r)/ 2;    if(a[mid] &lt;= v)l = mid + 1;    else r = mid;  &#125;  return l;//如果存在目标值，返回的是目标值后一个值的下标，寻找目标值下标的话要 -1;&#125;</code></pre><h2 id="分析-Analysis"><a href="#分析-Analysis" class="headerlink" title="分析(Analysis)"></a>分析(Analysis)</h2><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>以寻找上界为例：<br>大小关系分析如下：  </p><ol><li>a[mid] = v:已经找到了一个符合条件的值，但是它的左边可能还有合适的值，继续向左找：r = mid;  </li><li>a[mid] &gt; v:要求的位置一定不在当前位置的后面，但是当前位置可能是答案(数组中没有目标值，并且当前位置是第一个大于目标值的位置)，所以向左找：r = mid;</li><li>a[mid] &lt; v:要求的位置一定不在当前位置以及当前位置的前面，所以向前找：l = mid + 1;</li></ol><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>二分查找的时间复杂度为$O(logn)$。</p><h2 id="细节-Detail"><a href="#细节-Detail" class="headerlink" title="细节(Detail)"></a>细节(Detail)</h2><p>函数返回上下界是受制于数组上下界的，如果目标值就在数组上界，那么也只会返回数组的上界，而不是目标值上界。</p><p><img src="https://i.loli.net/2021/07/10/BVA6WrYZlUjpFmQ.jpg" alt="示例4"></p><h2 id="补充-Supplement-浮点数二分"><a href="#补充-Supplement-浮点数二分" class="headerlink" title="补充(Supplement)(浮点数二分)"></a>补充(Supplement)(浮点数二分)</h2><p>相较于整数二分有复杂的边界问题，浮点数二分友善了很多。</p><pre><code class="line-numbers language-cpp">double Binary_search(double l, double r)&#123;  double mid;  while(r - l &gt; 1e-(k + 2))//k是题目要求的精确度  &#123;    mid = (l + r) / 2;    if(check())l = mid;    else r = mid;  &#125;  return l;&#125;</code></pre><hr><h2 id="应用：数的范围"><a href="#应用：数的范围" class="headerlink" title="应用：数的范围"></a>应用：数的范围</h2><blockquote><blockquote><p>给定一个按照升序排列的长度为n的整数数组，以及 q 个查询。<br>对于每个查询，返回一个元素k的起始位置和终止位置（位置从0开始计数）。<br>如果数组中不存在该元素，则返回“-1 -1”。<br><strong>输入格式</strong><br>第一行包含整数n和q，表示数组长度和询问个数。<br>第二行包含n个整数（均在1~10000范围内），表示完整数组。<br>接下来q行，每行包含一个整数k，表示一个询问元素。<br><strong>输出格式</strong><br>共q行，每行包含两个整数，表示所求元素的起始位置和终止位置。<br>如果数组中不存在该元素，则返回“-1 -1”。<br><strong>数据范围</strong><br>1≤n≤100000<br>1≤q≤10000<br>1≤k≤10000<br><strong>输入样例：</strong><br>6 3<br>1 2 2 3 3 4<br>3<br>4<br>5<br><strong>输出样例：</strong><br>3 4<br>5 5<br>-1 -1  </p></blockquote></blockquote><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>注意细节，照着板子做就行啦~</p><hr><p>二分其实不仅限于寻找数的范围，其更常用的是在特定条件下求最值的问题。 更常用的代码模板是这样的：</p><ol><li><p>区间分为[l,mid],[mid + 1, r]:</p><pre><code class="line-numbers language-cpp">int bsearch1(int l, int r)&#123;    int mid = l + r &gt;&gt; 1;    if(check(mid))r = mid;    else l = mid + 1;&#125;</code></pre></li><li><p>区间分为[l,mid -1],[mid,r]:</p><pre><code class="line-numbers language-cpp">int bsearch2(int l,int r)&#123;    int mid = l + r +1&gt;&gt; 1;    if(check(mid))l = mid;    else r = mid -1;&#125;</code></pre><hr><p>暂时先这么多吧。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序(Merge sort)</title>
      <link href="/2021/07/09/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F(Merge%20sort)/"/>
      <url>/2021/07/09/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F(Merge%20sort)/</url>
      
        <content type="html"><![CDATA[<h2 id="简介-Introduction"><a href="#简介-Introduction" class="headerlink" title="简介(Introduction)"></a>简介(Introduction)</h2><blockquote><blockquote><p>归并排序（Merge Sort）是建立在归并操作上的一种有效，<strong>稳定的</strong>排序算法，该算法是采用<strong>分治法</strong>（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p></blockquote></blockquote><h2 id="描述-Description"><a href="#描述-Description" class="headerlink" title="描述(Description)"></a>描述(Description)</h2><p>归并排序的核心思想是“分而治之”，把一个问题一步一步拆解为一个最简单的问题。</p><h2 id="示例-Example"><a href="#示例-Example" class="headerlink" title="示例(Example)"></a>示例(Example)</h2><p><img src="https://i.loli.net/2021/07/09/46cuGVwyNxEBFC8.jpg" alt="归并"></p><h2 id="代码实现-Code"><a href="#代码实现-Code" class="headerlink" title="代码实现(Code)"></a>代码实现(Code)</h2><pre><code class="line-numbers language-cpp">void merge_sort(int a[], int l , int r)&#123;  if(l &gt;= r)return;  int mid = l + r &gt;&gt; 1;  merge_sort(a, l, mid);//左递归处理  merge_sort(a, mid + 1, r);//右递归处理    int k = 0, i = l, j = mid + 1；  while(i &lt;= mid &amp;&amp; j &lt;= r)    if(a[i] &lt; a[j])t[k++] = a[i++];//数组作为临时储存空间    else t[k++] = a[j++];  while(i &lt;= mid)t[k++] = a[i++];  while(j &lt;= r)t[k++] = a[j++];//左右两者其中一个未遍历完成的直接把剩下整个接到数组后面  for(int i = l,j = 0; i &lt;= r ; i++, j++)  a[i] = t[j];//返回给a数组&#125;</code></pre><h2 id="性能分析-Analysis"><a href="#性能分析-Analysis" class="headerlink" title="性能分析(Analysis)"></a>性能分析(Analysis)</h2><p>归并排序平均时间复杂度为$O(nlogn)$,相比快排具有额外的空间复杂度$O(n)$。</p><hr><h2 id="应用：求逆序对的数量"><a href="#应用：求逆序对的数量" class="headerlink" title="应用：求逆序对的数量"></a>应用：求逆序对的数量</h2><blockquote><blockquote><p>给定一个长度为$n$的整数数列，请你计算数列中的逆序对的数量。<br>逆序对的定义如下：对于数列的第 $i$ 个和第 $j$ 个元素，如果满足 $i &lt; j $且 $a[i] &gt; a[j]$，则其为一个逆序对；否则不是。<br><strong>输入格式</strong><br>第一行包含整数$n$，表示数列的长度。<br>第二行包含 $n$ 个整数，表示整个数列。<br><strong>输出格式</strong><br>输出一个整数，表示逆序对的个数。<br><strong>数据范围</strong><br>$1≤n≤100000$<br><strong>输入样例：</strong><br>6<br>2 3 4 5 6 1<br><strong>输出样例：</strong><br>5</p></blockquote></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>受归并排序启发，对于每一段归并过程中添加一个记录答案的变量res。进行左右比较给临时数组存值时，<strong>res = mid - i +1</strong>，表示左边一直到mid的所有值都比当前的j指向的值大，构成逆序对。最后每段返回res即可。(ps:注意数据范围)</p>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序(Quick sort)</title>
      <link href="/2021/07/08/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F(Quick%20sort)/"/>
      <url>/2021/07/08/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F(Quick%20sort)/</url>
      
        <content type="html"><![CDATA[<h2 id="简介-Introduction"><a href="#简介-Introduction" class="headerlink" title="简介(Introduction)"></a>简介(Introduction)</h2><blockquote><p>快速排序由C. A. R. Hoare在1960年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p></blockquote><h2 id="描述-Description"><a href="#描述-Description" class="headerlink" title="描述(Description)"></a>描述(Description)</h2><p>快排的大致过程是对于一个无序序列，找到一个“基准数”，通过交换，使得序列分为两块，之后这两块再进行递归处理。基准数随便选，这里暂不考虑“基准数”选择的讲究。</p><h2 id="示例-Example"><a href="#示例-Example" class="headerlink" title="示例(Example)"></a>示例(Example)</h2><p><img src="https://i.loli.net/2021/07/09/zdV47rZ2OfvqjJ8.png" alt="快排"></p><h2 id="代码实现-Code"><a href="#代码实现-Code" class="headerlink" title="代码实现(Code)"></a>代码实现(Code)</h2><pre><code class="line-numbers language-cpp">void quick_sort(int a[], int l, int r)&#123;  if (l == r)  return ;  int flag = a[(l + r) / 2],i = l - 1, j = r + 1;  while(i &lt; j)  &#123;    while(a[++i] &lt; flag);    while(a[--j] &gt; flag);    if(i &lt; j)swap(a[i],a[j]);  &#125;  quick_sort(a,l,j);  quick_sort(a,j + 1,r);&#125;</code></pre><h2 id="性能分析-Analysis"><a href="#性能分析-Analysis" class="headerlink" title="性能分析(Analysis)"></a>性能分析(Analysis)</h2><p>快速排序在理想情况下的时间复杂度为$O(nlogn)$,在极端情况下时间复杂度为$O(n^2)$。</p><hr><h2 id="应用-快速选择"><a href="#应用-快速选择" class="headerlink" title="应用:快速选择"></a>应用:快速选择</h2><blockquote><blockquote><p>给定一个长度为n的整数数列，以及一个整数k，请用快速选择算法求出数列从小到大排序后的第k个数。<br><strong>输入格式</strong><br>第一行包含两个整数 n 和 k。<br>第二行包含 n 个整数（所有整数均在1~109范围内），表示整数数列。<br><strong>输出格式</strong><br>输出一个整数，表示数列的第k小数。<br><strong>数据范围</strong><br>1≤n≤100000,<br>1≤k≤n.<br><strong>输入样例：</strong><br>5 3<br>2 4 1 5 3<br><strong>输出样例：</strong><br>3</p></blockquote></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>如果单纯利用快排进行排序，时间复杂度就是$O(nlogn)$。但是本题可以利用快排的性质，<strong>只递归第k个数所在的那一半</strong>，把时间复杂度优化到$O(n)$。</p>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
