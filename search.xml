<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>二分查找(Binary Search)</title>
      <link href="/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE(Binary%20Search)"/>
      <url>/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE(Binary%20Search)</url>
      
        <content type="html"><![CDATA[<h2 id="简介-Introduction"><a href="#简介-Introduction" class="headerlink" title="简介(Introduction)"></a>简介(Introduction)</h2><blockquote><blockquote><p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。</p></blockquote></blockquote><h2 id="描述-Description"><a href="#描述-Description" class="headerlink" title="描述(Description)"></a>描述(Description)</h2><p>二分查找的前提是目标已近排好序。二分查找每次取半查找保证其高效率。</p><h2 id="示例-Example"><a href="#示例-Example" class="headerlink" title="示例(Example)"></a>示例(Example)</h2><ol><li>二分查找下界</li></ol><p>在目标数组中找3： </p><p><img src="https://i.loli.net/2021/07/10/KgzGUhaVTLY9AtP.jpg" alt="示例1"></p><p>在目标数组中找4：</p><p><img src="https://i.loli.net/2021/07/10/YqfVMgGBbL1lQv8.jpg" alt="示例2"></p><p>可见当找不到目标值时，会找到一个合适的，可以插入目标值的位置的下标。</p><ol start="2"><li>二分查找上界</li></ol><p>在目标数组中找3：  </p><p><img src="https://i.loli.net/2021/07/10/1hYGFRV4p3zwaDg.jpg" alt="示例3"></p><p>同理，如果找不到目标值，也会找到一个合适的、目标值可插入的位置。<br>通过上面演示可以得到：无论问题如何，<strong>二分查找本身一定可以找到一个“答案”。</strong></p><h2 id="代码实现-Code-整数二分"><a href="#代码实现-Code-整数二分" class="headerlink" title="代码实现(Code)(整数二分)"></a>代码实现(Code)(整数二分)</h2><pre><code class="line-numbers language-cpp">//寻找下界：int lower(int a[], int l, int r, int v)&#123;  int mid;  while(l &lt; r)  &#123;    mid = (l + r) /2;    if(a[mid] &gt;= v) r = mid;    else l = mid + 1;  &#125;  return l;&#125;//寻找上界：int upper(int a[], int l, int r, int v)&#123;  int mid;  while(l &lt; r)  &#123;    mid = (l + r)/ 2;    if(a[mid] &lt;= v)l = mid + 1;    else r = mid;  &#125;  return l;//如果存在目标值，返回的是目标值后一个值的下标，寻找目标值下标的话要 -1;&#125;</code></pre><h2 id="分析-Analysis"><a href="#分析-Analysis" class="headerlink" title="分析(Analysis)"></a>分析(Analysis)</h2><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>以寻找上界为例：<br>大小关系分析如下：  </p><ol><li>a[mid] = v:已经找到了一个符合条件的值，但是它的左边可能还有合适的值，继续向左找：r = mid;  </li><li>a[mid] &gt; v:要求的位置一定不在当前位置的后面，但是当前位置可能是答案(数组中没有目标值，并且当前位置是第一个大于目标值的位置)，所以向左找：r = mid;</li><li>a[mid] &lt; v:要求的位置一定不在当前位置以及当前位置的前面，所以向前找：l = mid + 1;</li></ol><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>二分查找的时间复杂度为$O(logn)$。</p><h2 id="细节-Detail"><a href="#细节-Detail" class="headerlink" title="细节(Detail)"></a>细节(Detail)</h2><p>函数返回上下界是受制于数组上下界的，如果目标值就在数组上界，那么也只会返回数组的上界，而不是目标值上界。</p><p><img src="https://i.loli.net/2021/07/10/BVA6WrYZlUjpFmQ.jpg" alt="示例4"></p><h2 id="补充-Supplement-浮点数二分"><a href="#补充-Supplement-浮点数二分" class="headerlink" title="补充(Supplement)(浮点数二分)"></a>补充(Supplement)(浮点数二分)</h2><p>相较于整数二分有复杂的边界问题，浮点数二分友善了很多。</p><pre><code class="line-numbers language-cpp">double Binary_search(double l, double r)&#123;  double mid;  while(r - l &gt; 1e-(k + 2))//k是题目要求的精确度  &#123;    mid = (l + r) / 2;    if(check())l = mid;    else r = mid;  &#125;  return l;&#125;</code></pre><hr><h2 id="应用：数的范围"><a href="#应用：数的范围" class="headerlink" title="应用：数的范围"></a>应用：数的范围</h2><blockquote><blockquote><p>给定一个按照升序排列的长度为n的整数数组，以及 q 个查询。<br>对于每个查询，返回一个元素k的起始位置和终止位置（位置从0开始计数）。<br>如果数组中不存在该元素，则返回“-1 -1”。<br><strong>输入格式</strong><br>第一行包含整数n和q，表示数组长度和询问个数。<br>第二行包含n个整数（均在1~10000范围内），表示完整数组。<br>接下来q行，每行包含一个整数k，表示一个询问元素。<br><strong>输出格式</strong><br>共q行，每行包含两个整数，表示所求元素的起始位置和终止位置。<br>如果数组中不存在该元素，则返回“-1 -1”。<br><strong>数据范围</strong><br>1≤n≤100000<br>1≤q≤10000<br>1≤k≤10000<br><strong>输入样例：</strong><br>6 3<br>1 2 2 3 3 4<br>3<br>4<br>5<br><strong>输出样例：</strong><br>3 4<br>5 5<br>-1 -1  </p></blockquote></blockquote><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>注意细节，照着板子做就行啦~</p><hr><p>二分其实不仅限于寻找数的范围，其更常用的是在特定条件下求最值的问题。 更常用的代码模板是这样的：</p><ol><li><p>区间分为[l,mid],[mid + 1, r]:</p><pre><code class="line-numbers language-cpp">int bsearch1(int l, int r)&#123;    int mid = l + r &gt;&gt; 1;    if(check(mid))r = mid;    else l = mid + 1;&#125;</code></pre></li><li><p>区间分为[l,mid -1],[mid,r]:</p><pre><code class="line-numbers language-cpp">int bsearch2(int l,int r)&#123;    int mid = l + r +1&gt;&gt; 1;    if(check(mid))l = mid;    else r = mid -1;&#125;</code></pre><hr><p>暂时先这么多吧。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序(Merge sort)</title>
      <link href="/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F(Merge%20sort)"/>
      <url>/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F(Merge%20sort)</url>
      
        <content type="html"><![CDATA[<h2 id="简介-Introduction"><a href="#简介-Introduction" class="headerlink" title="简介(Introduction)"></a>简介(Introduction)</h2><blockquote><blockquote><p>归并排序（Merge Sort）是建立在归并操作上的一种有效，<strong>稳定的</strong>排序算法，该算法是采用<strong>分治法</strong>（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p></blockquote></blockquote><h2 id="描述-Description"><a href="#描述-Description" class="headerlink" title="描述(Description)"></a>描述(Description)</h2><p>归并排序的核心思想是“分而治之”，把一个问题一步一步拆解为一个最简单的问题。</p><h2 id="示例-Example"><a href="#示例-Example" class="headerlink" title="示例(Example)"></a>示例(Example)</h2><p><img src="https://i.loli.net/2021/07/09/46cuGVwyNxEBFC8.jpg" alt="归并"></p><h2 id="代码实现-Code"><a href="#代码实现-Code" class="headerlink" title="代码实现(Code)"></a>代码实现(Code)</h2><pre><code class="line-numbers language-cpp">void merge_sort(int a[], int l , int r)&#123;  if(l &gt;= r)return;  int mid = l + r &gt;&gt; 1;  merge_sort(a, l, mid);//左递归处理  merge_sort(a, mid + 1, r);//右递归处理    int k = 0, i = l, j = mid + 1；  while(i &lt;= mid &amp;&amp; j &lt;= r)    if(a[i] &lt; a[j])t[k++] = a[i++];//数组作为临时储存空间    else t[k++] = a[j++];  while(i &lt;= mid)t[k++] = a[i++];  while(j &lt;= r)t[k++] = a[j++];//左右两者其中一个未遍历完成的直接把剩下整个接到数组后面  for(int i = l,j = 0; i &lt;= r ; i++, j++)  a[i] = t[j];//返回给a数组&#125;</code></pre><h2 id="性能分析-Analysis"><a href="#性能分析-Analysis" class="headerlink" title="性能分析(Analysis)"></a>性能分析(Analysis)</h2><p>归并排序平均时间复杂度为$O(nlogn)$,相比快排具有额外的空间复杂度$O(n)$。</p><hr><h2 id="应用：求逆序对的数量"><a href="#应用：求逆序对的数量" class="headerlink" title="应用：求逆序对的数量"></a>应用：求逆序对的数量</h2><blockquote><blockquote><p>给定一个长度为$n$的整数数列，请你计算数列中的逆序对的数量。<br>逆序对的定义如下：对于数列的第 $i$ 个和第 $j$ 个元素，如果满足 $i &lt; j $且 $a[i] &gt; a[j]$，则其为一个逆序对；否则不是。<br><strong>输入格式</strong><br>第一行包含整数$n$，表示数列的长度。<br>第二行包含 $n$ 个整数，表示整个数列。<br><strong>输出格式</strong><br>输出一个整数，表示逆序对的个数。<br><strong>数据范围</strong><br>$1≤n≤100000$<br><strong>输入样例：</strong><br>6<br>2 3 4 5 6 1<br><strong>输出样例：</strong><br>5</p></blockquote></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>受归并排序启发，对于每一段归并过程中添加一个记录答案的变量res。进行左右比较给临时数组存值时，<strong>res = mid - i +1</strong>，表示左边一直到mid的所有值都比当前的j指向的值大，构成逆序对。最后每段返回res即可。(ps:注意数据范围)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序(Quick sort)</title>
      <link href="/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F(Quick%20sort)"/>
      <url>/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F(Quick%20sort)</url>
      
        <content type="html"><![CDATA[<h2 id="简介-Introduction"><a href="#简介-Introduction" class="headerlink" title="简介(Introduction)"></a>简介(Introduction)</h2><blockquote><p>快速排序由C. A. R. Hoare在1960年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p></blockquote><h2 id="描述-Description"><a href="#描述-Description" class="headerlink" title="描述(Description)"></a>描述(Description)</h2><p>快排的大致过程是对于一个无序序列，找到一个“基准数”，通过交换，使得序列分为两块，之后这两块再进行递归处理。基准数随便选，这里暂不考虑“基准数”选择的讲究。</p><h2 id="示例-Example"><a href="#示例-Example" class="headerlink" title="示例(Example)"></a>示例(Example)</h2><p><img src="https://i.loli.net/2021/07/09/zdV47rZ2OfvqjJ8.png" alt="快排"></p><h2 id="代码实现-Code"><a href="#代码实现-Code" class="headerlink" title="代码实现(Code)"></a>代码实现(Code)</h2><pre><code class="line-numbers language-cpp">void quick_sort(int a[], int l, int r)&#123;  if (l == r)  return ;  int flag = a[(l + r) / 2],i = l - 1, j = r + 1;  while(i &lt; j)  &#123;    while(a[++i] &lt; flag);    while(a[--j] &gt; flag);    if(i &lt; j)swap(a[i],a[j]);  &#125;  quick_sort(a,l,j);  quick_sort(a,j + 1,r);&#125;</code></pre><h2 id="性能分析-Analysis"><a href="#性能分析-Analysis" class="headerlink" title="性能分析(Analysis)"></a>性能分析(Analysis)</h2><p>快速排序在理想情况下的时间复杂度为$O(nlogn)$,在极端情况下时间复杂度为$O(n^2)$。</p><hr><h2 id="应用-快速选择"><a href="#应用-快速选择" class="headerlink" title="应用:快速选择"></a>应用:快速选择</h2><blockquote><blockquote><p>给定一个长度为n的整数数列，以及一个整数k，请用快速选择算法求出数列从小到大排序后的第k个数。<br><strong>输入格式</strong><br>第一行包含两个整数 n 和 k。<br>第二行包含 n 个整数（所有整数均在1~109范围内），表示整数数列。<br><strong>输出格式</strong><br>输出一个整数，表示数列的第k小数。<br><strong>数据范围</strong><br>1≤n≤100000,<br>1≤k≤n.<br><strong>输入样例：</strong><br>5 3<br>2 4 1 5 3<br><strong>输出样例：</strong><br>3</p></blockquote></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>如果单纯利用快排进行排序，时间复杂度就是$O(nlogn)$。但是本题可以利用快排的性质，<strong>只递归第k个数所在的那一半</strong>，把时间复杂度优化到$O(n)$。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
