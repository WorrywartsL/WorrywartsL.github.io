<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>哈希表(Hash table)</title>
      <link href="/2021/07/15/"/>
      <url>/2021/07/15/</url>
      
        <content type="html"><![CDATA[<h2 id="简介-Introduction"><a href="#简介-Introduction" class="headerlink" title="简介(Introduction)"></a>简介(Introduction)</h2><blockquote><blockquote><p><strong>散列表（Hash table，也叫哈希表）</strong>，是根据<strong>关键码值(Key value)</strong> 而直接进行访问的数据结构。也就是说，它通过把关键码值<strong>映射</strong>到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做<strong>散列函数</strong>，存放记录的数组叫做<strong>散列表</strong>。  </p></blockquote></blockquote><h2 id="描述-Description"><a href="#描述-Description" class="headerlink" title="描述(Description)"></a>描述(Description)</h2><p>哈希表最主要的作用是把一个庞大的数据体系映射到一个比较小的空间。<strong>离散化</strong>是一个非常特殊的哈希方式。  </p><p><strong>模拟散列表</strong>一般有如下基本操作：1：插入一个数；2：查询一个数是否在集合中出现。<br>我们一般用一个hash函数来实现映射操作。比如说要把$0-10^9$的数映射到$0\sim10^5$。我们只要把输入的数$mod10^5$即可。但是由于值域的缩小，很有可能出现一个<strong>问题</strong>：把两个数映射为一个数。如：$7 mod 5 = 2,17 mod 5 = 2$。<br>我们为了处理这样的问题，就有了<strong>开放寻址法</strong>和<strong>拉链法</strong>。</p><ol><li>拉链法：采用<strong>邻接表</strong>来存储取mod后值相等的数的集合。时间复杂度近似$O(1)$ 一般来说，mod值(数组的范围)要取为<strong>质数</strong>，并且要<strong>尽可能离2的整次幂远</strong>。这样可以使重复的hash值尽可能的少。<h2 id="代码实现-Code"><a href="#代码实现-Code" class="headerlink" title="代码实现(Code)"></a>代码实现(Code)</h2></li><li>插入操作<pre><code class="line-numbers language-cpp">int h[N],e[N],ne[N],idx;void Insert(int x)&#123; int k = (x %N + N) % N;//要把f数也映射为正数。(c++中负数mod正数还是负数。) e[idx] = k,ne[idx] =h[k],h[k] = idx++;&#125;</code></pre></li><li>查询操作<pre><code class="line-numbers language-cpp">bool find(int x)&#123; int k = (x % N + N) % N; for(int i = h[k];i!=-1;i = ne[i]) if(e[i] = x)return true; return false;&#125;</code></pre></li><li>开放寻址法：采用一个数组来存储。  </li></ol><p><strong>插入操作</strong>：从前往后寻找hash值，如果当前位置有值，就去下一个值。<br><strong>查找操作</strong>：从前往后找hash值，如果当前位置有值，并且是目标值，那么就找到了。如果当前位置没有值，那么说明目标值不存在。寻找mod值(数组范围)的原则和上面一样。  </p><h2 id="代码实现-Code-1"><a href="#代码实现-Code-1" class="headerlink" title="代码实现(Code)"></a>代码实现(Code)</h2><p>核心操作；</p><pre><code class="line-numbers language-cpp">int h[N];//(N 开到总数的两到三倍附近,保证比所有存的值多)const int null = 0x3f3f3f3f;//定义正无穷，表示不存在目标数。(要用这个值初始数组memset(h,0x3f,sizeof h));int find(int x)&#123;    int k = (x % N + N) % N;    while(h[x] != null &amp;&amp; h[k] != x)//说明当前位置有值，但是不是目标值。    &#123;        k++;        if(k == N)k = 0;//如果走到末尾，那么从头再找。        //这个过程一定会停止，因为总共的空位比总的数的个数多。    &#125;    return k;//和二分查找结果类似，如果有目标值的位置，那么就范围这个位置，否则返回目标值应该在的位置。&#125;</code></pre><p>插入和查询操作都可以基于此来完成。  </p><ol><li>插入操作：  <pre><code class="line-numbers language-cpp">int k = find(x);h[k] = x;</code></pre></li><li>查询操作：  <pre><code class="line-numbers language-cpp">int k = find(x);if(h[k]!= x) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;//找到了else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;//没找到</code></pre></li></ol><hr><p>下面介绍另外一种哈希：<strong>字符串哈希</strong><br>对于字符串哈希，我们先要预处理出来<strong>字符串所有前缀的哈希</strong>。<br>例如：对于字符串$abbcde$,我们令h[0] = 0(0个字符的字符串的哈希值就是0),h[1]对应$a$的哈希值,h[2]对应$ab$的哈希值,h[3]对应$abb$的哈希值，以此类推………<br>对于哈希值：我们将字符串看成一个$p$进制的数。<br>例如：对于字符串$abbcde$，我们把它看成一个$p$进制的数，第一位是$a$，第二位是$b$，以此类推……我们把$ a\sim z $与$ 1\sim 26 $一一对应，那么该数就是$ (122345)_p $。那么就对应一个十进制数大小为：$(1 × p^5 + 2× p^4 + 2 × p^3 + 3 × p^2 + 4 × p + 5)$。之后这个结果再$mod q$,就能把结果映射到$ 0\sim q-1 $。基于此，我们就能够对于任何字符串进行哈希映射。(注意：一般情况下，我们不能把任何一个字符映射为0，因为不同进制中0还是0)。<br> 字符串按理和前面的整数映射一样，会出现多个同样的字符串映射到同一个数字的问题，但是<b> 当$p$取$131$或者$13331$，$q$取$2^{64}$时</b>。我们可以认为上面的问题<strong>不会出现</strong>。<br>通过这样的哈希方式加上预处理出来的前缀哈希，就可以求出所有子串的哈希值。实现方式如下：<br>例如，我们要求一个字符串中$[l,r]$段子串。现在我们通过预处理已经有了$[1,l - 1]$和$[1,r]$的<strong>前缀子串</strong>对应哈希值。<br>有如图处理：  </p><p><img src="https://i.loli.net/2021/07/15/VxU24wbHkL3WdpX.jpg" alt="字符串哈希示例"></p><p>经过处理后，我们再考虑$h[x]mod2^{64}$的问题。很简单，可以用unsigned long long 来存值，相当于取$mod2^{64}$。<br>最后，和前缀和类似，预处理操作：$h[i] = h[i -1] × p + str[i]$.(事实上这是个秦九韶算法算多项式)。  </p><h2 id="代码实现-Code-2"><a href="#代码实现-Code-2" class="headerlink" title="代码实现(Code)"></a>代码实现(Code)</h2><ol><li>计算指定子串hash值。<pre><code class="line-numbers language-cpp">typedef unsigned long long ULL;ULL get(int l, int r)//查找过程&#123; return h[r] - h[l -1] * p[r - l + 1];&#125;</code></pre></li><li>预处理<pre><code class="line-numbers language-cpp"> p[0] = 1;//p的0次方是1； for(int i = 1;i &lt;=n; i++) &#123;     p[i] = p[i - 1] * P;//p的n次幂预处理。     h[i] = h[i - 1] * P + str[i];//hash预处理 &#125;</code></pre>至此，我们就完成了字符串哈希的过程。<br>除了求循环节之外，大部分KMP能做的hash也能做。</li></ol><hr><p>模拟散列表比较容易理解，字符串哈希需要好好领悟。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟堆(Heap)</title>
      <link href="/2021/07/15/"/>
      <url>/2021/07/15/</url>
      
        <content type="html"><![CDATA[<h2 id="简介-Introduction"><a href="#简介-Introduction" class="headerlink" title="简介(Introduction)"></a>简介(Introduction)</h2><blockquote><blockquote><p><strong>堆(Heap)</strong> 是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵<strong>完全二叉树</strong>的数组对象。</p></blockquote></blockquote><h2 id="描述-Description"><a href="#描述-Description" class="headerlink" title="描述(Description)"></a>描述(Description)</h2><p>堆是来维护一个数组集合的，常见的操作有：插入一个数、求集合的最小值、删除最小值、删除任一元素，修改任一元素。这里只写数组模拟的堆。以小根堆为例，堆有如下性质：<strong>每个点都小于等于它的左右儿子</strong>。<br>模拟堆是用一个一维数组存储的，具体存储形式如下：父节点为$x$,其左儿子为$2x$,其右儿子为$2x+1$。例如：根(父)为1，左儿子为2，右儿子为3。  </p><p>  堆的主要操作由以下两个操作组合实现：</p><h2 id="代码实现-Code"><a href="#代码实现-Code" class="headerlink" title="代码实现(Code)"></a>代码实现(Code)</h2><ol><li><p>down 操作:把一个元素往下移(直到不符合下移条件)</p><pre><code class="line-numbers language-cpp">void down(int u)//下移&#123;//sizeh 为堆中元素的总个数。 int t = u; if(u * 2 &lt;= sizeh&amp;&amp;h[t] &gt; h[u * 2])t = u *2;//等号不能忘，不等号方向留意，找小的。 if(u * 2 + 1&lt;= sizeh &amp;&amp;h[t] &gt; h[u * 2 + 1])t = u * 2 +1; if(t != u) &#123;     heap_swap(t,u);     down(t);//递归实现 &#125;&#125;</code></pre></li><li><p>up 操作：把一个元素往上移(直到不符合上移条件)</p><pre><code class="line-numbers language-cpp">void up(int u)//上移&#123; while(u / 2 &amp;&amp; h[u] &lt; h[u / 2])//只要比较它的父节点，因为它的兄弟节点一定大于等于它的父节点。 &#123;     heap_swap(u, u / 2);     u /= 2;//循环实现 &#125;&#125;</code></pre><p>以上两个操作的复杂度都和树高成正比，因此时间复杂度为$O(log)$<br>有了以上两个操作，我们就可以实现下面的基本操作：  </p></li><li><p>求最小值：根据小根堆的性质我们可以知道，第一个数就是最小值。 $O(1)$</p></li><li><p>插入一个数：把这个数放在数组尾部(数组计数+1)，然后up这个数。  $O(logn)$</p></li><li><p> 删除最小值：用最后一个数覆盖掉第一个数(最小值)，数组计数减去1，然后down一遍第一个数。  </p></li><li><p>删除一个数：用最后一个数覆盖掉目标数，然后down、up一下现在这个位置上的数。(由于x的大小未知，可能up、也可能down)  $O(logn)$</p></li><li><p>修改任一一个数：把这个位置的数该为x，然后down、up一下。  </p></li></ol><hr><h2 id="应用：堆排序"><a href="#应用：堆排序" class="headerlink" title="应用：堆排序"></a>应用：堆排序</h2><blockquote><blockquote><p>输入一个长度为n的整数数列，从小到大输出前m小的数。<br><strong>输入格式</strong><br>第一行包含整数n和m。<br>第二行包含n个整数，表示整数数列。<br><strong>输出格式</strong><br>共一行，包含m个整数，表示整数数列中前m小的数。<br><strong>数据范围</strong><br>$1≤m≤n≤10^5$，<br>$1≤$数列中元素$≤10^9$<br><strong>输入样例：</strong><br>5 3<br>4 5 1 3 2<br><strong>输出样例：</strong><br>1 2 3  </p></blockquote></blockquote><h2 id="分析-Analysis"><a href="#分析-Analysis" class="headerlink" title="分析(Analysis)"></a>分析(Analysis)</h2><p>建堆然后取头、去头循环即可。<br>对于建堆：朴素做法为一个一个插入，时间复杂度为$O(nlogn)$,有一个$O(n)$的优化：从$ \frac{n}{2}$down到$1$即可。</p><h2 id="代码实现-Code-1"><a href="#代码实现-Code-1" class="headerlink" title="代码实现(Code)"></a>代码实现(Code)</h2><pre><code class="line-numbers language-cpp">for(int i = n / 2; i;i--)down(i);</code></pre><hr><p>堆的基本操作，比较好理解。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集(Union-find disjoint sets)</title>
      <link href="/2021/07/15/"/>
      <url>/2021/07/15/</url>
      
        <content type="html"><![CDATA[<h2 id="简介-Introduction"><a href="#简介-Introduction" class="headerlink" title="简介(Introduction)"></a>简介(Introduction)</h2><blockquote><blockquote><p>并查集是一种树型的数据结构，用于处理一些不相交集合（disjoint sets）的合并及查询问题。</p></blockquote></blockquote><h2 id="描述-Description"><a href="#描述-Description" class="headerlink" title="描述(Description)"></a>描述(Description)</h2><p>并查集能快速地将两个集合合并、查询两个元素是否属于同一个集合。基本原理是用树的形式来维护每个集合，每个集合的编号是他的根节点的编号，每个节点存储了它的父节点。加上路径压缩优化后，其实现操作的时间复杂度近乎为$O(1)$。</p><h2 id="代码实现-Code"><a href="#代码实现-Code" class="headerlink" title="代码实现(Code)"></a>代码实现(Code)</h2><ol><li>初始：<pre><code class="line-numbers language-cpp">for(int i = 1 ; i &lt;= n ; i++) p[i] = i;//初始时，每个元素都互不相关，在自己的集合中。</code></pre></li><li>核心:找祖宗 + 路径压缩<pre><code class="line-numbers language-cpp">int find(int x)&#123; if(p[x] != x) p[x] = find(p[x]); return p[x];&#125;</code></pre></li><li>基本操作1：元素集合合并<pre><code class="line-numbers language-cpp">void merge(int a,int b)&#123; p[find(a)] = find[b];//a集合归于b集合&#125;</code></pre></li><li>基本操作2：判断是否在同一集合<pre><code class="line-numbers language-cpp">bool jud(int a, int b)&#123; if(find(a) == find(b)) return true; return false;&#125;</code></pre></li></ol><hr><h2 id="应用：食物链"><a href="#应用：食物链" class="headerlink" title="应用：食物链"></a>应用：食物链</h2><blockquote><blockquote><p>动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。<br>A吃B， B吃C，C吃A。<br>现有N个动物，以1－N编号。<br>每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。<br>有人用两种说法对这N个动物所构成的食物链关系进行描述：<br>第一种说法是”1 X Y”，表示X和Y是同类。<br>第二种说法是”2 X Y”，表示X吃Y。<br>此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。<br>当一句话满足下列三条之一时，这句话就是假话，否则就是真话。<br>1） 当前的话与前面的某些真的话冲突，就是假话；<br>2） 当前的话中X或Y比N大，就是假话；<br>3） 当前的话表示X吃X，就是假话。<br>你的任务是根据给定的N和K句话，输出假话的总数。<br><strong>输入格式</strong><br>第一行是两个整数N和K，以一个空格分隔。<br>以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。<br>若D=1，则表示X和Y是同类。<br>若D=2，则表示X吃Y。<br><strong>输出格式</strong><br>只有一个整数，表示假话的数目。<br><strong>数据范围</strong><br>1≤N≤50000,<br>0≤K≤100000<br><strong>输入样例：</strong><br>100 7<br>1 101 1<br>2 1 2<br>2 2 3<br>2 3 3<br>1 1 3<br>2 3 1<br>1 5 5<br><strong>输出样例：</strong><br>3  </p></blockquote></blockquote><h2 id="分析-Analysis"><a href="#分析-Analysis" class="headerlink" title="分析(Analysis)"></a>分析(Analysis)</h2><p>我们维护并查集的同时维护$d[x]$表示每个结点到根结点的距离，以便判断结点之间的关系。可以以距离模3来归为三大类：<br>1：模3余1，表示可以吃根结点(代表一种动物)。<br>2：模3余2，可以被根节点吃。<br>3：模3余0，和根结点是同类。<br>有如下情况:  </p><ol><li>最简单的假话判断：$x&gt;n$ 或者$y&gt;n$。  </li><li>吃与被吃的假话判断：<br>当$D = 1$时，表示两个动物是同类，即在同一颗树上。<br>此时有两种情况：<br>1：两个动物确实在一个树上，那么只要两个动物距离祖宗的差值$d[y]-d[x]$模3为0，那么就一定是假话。(只有差值是三的倍数才是同类)<br>2：两个动物不在一棵树上，我们无法判断，认为正确，并且连通这两课树。<br>设两个根节点的距离为d，则必有关系：$d[x] + d -d[y] %3 = 0 $，这里不妨取$d[x] + d -d[y] = 0$，即：$d =d[y] - d[x]$;<br><br>当$D = 2 $时，表示x吃y。<br>此时同样有两种情况：<br><br>1：两个动物确实在一个树上，那么与前面类似，只要满足$d[x] - d[y] - 1 $模3不为0，就说明这个吃的关系不成立，这是假话。<br><br>2：也和D=1时类似，不在同一个树上，无法判断，认为这是正确的。也有一个等量关系：$d[x] +d - d[y]$模3为1，不妨就取$d[x] + d - d[y] = 1$。那么就有：$d = d[y] - d[x] + 1$;<br>经过这样的分析就能做啦~ </li></ol><hr><p>都是并查集的经典操作。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Trie树</title>
      <link href="/2021/07/14/"/>
      <url>/2021/07/14/</url>
      
        <content type="html"><![CDATA[<h2 id="简介-Introduction"><a href="#简介-Introduction" class="headerlink" title="简介(Introduction)"></a>简介(Introduction)</h2><blockquote><blockquote><p><strong>Trie树</strong>又称单词查找树，字典树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。  </p></blockquote></blockquote><h2 id="描述-Description"><a href="#描述-Description" class="headerlink" title="描述(Description)"></a>描述(Description)</h2><p>Trie树一般用于高效存储和查找字符串集合的数据结构。其基本操作有：查找、插入和删除(删除操作比较少见)。</p><h2 id="示例-Example"><a href="#示例-Example" class="headerlink" title="示例(Example)"></a>示例(Example)</h2><p>Trie如是存储字符串集合：</p><p><img src="https://i.loli.net/2021/07/14/aiysr9jZSnzFcdT.png" alt="字典树示例1"></p><p>该Trie树实现了存储字符串：$abcdef、abdef、aced、bcdf、bcff、cdaa、bcdc$(打* 的表示这是单词的结尾)<br>下面来实现两个常见操作：插入和查询。</p><h2 id="代码实现-Code"><a href="#代码实现-Code" class="headerlink" title="代码实现(Code)"></a>代码实现(Code)</h2><ol><li><p>插入操作：</p><pre><code class="line-numbers language-cpp">char str[N];int son[N][26], cnt[N];//这里以26个小写英文字母为边。//cnt表示以当前这个结点为结尾的单词有多少个。int idx = 0;  // 下标是0的点是根节点也是空节点void Insert(str[])&#123; int p = 0; for(int i = 0; str[i];i++) &#123;     int t = str[i] - &#39;a&#39;;//a-z 映射到0-25；     if(!son[p][t])son[p][t] = ++idx;//这个结点不存在，就创建出来。     p = son[p][t];//结束的点就是最后一个点 &#125; cnt[p]++;//以这个点为结尾的一个单词。&#125;</code></pre></li><li><p>查询操作：</p><pre><code class="line-numbers language-cpp">int Query(char str[])&#123; int p = 0;//从根开始 for(int i = 0;str[i]; i++) &#123;     int t = str[i] - &#39;a&#39;;     if(!son[p][t]) return 0;//找不到就返回     p = son[p][t]; &#125; return cnt[p];&#125;</code></pre></li></ol><hr><p>Trie树的基本操作。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Trie树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP匹配算法</title>
      <link href="/2021/07/14/"/>
      <url>/2021/07/14/</url>
      
        <content type="html"><![CDATA[<h2 id="简介-Introduction"><a href="#简介-Introduction" class="headerlink" title="简介(Introduction)"></a>简介(Introduction)</h2><blockquote><blockquote><p>KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为克努特—莫里斯—普拉特操作（简称KMP算法）。KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个next()函数实现，函数本身包含了模式串的局部匹配信息。</p></blockquote></blockquote><h2 id="描述-Description"><a href="#描述-Description" class="headerlink" title="描述(Description)"></a>描述(Description)</h2><p>KMP是对朴素的字符匹配的一种优化。利用的是匹配失败过程中残留的有用信息。</p><h2 id="应用-KMP字符串"><a href="#应用-KMP字符串" class="headerlink" title="应用:KMP字符串"></a>应用:KMP字符串</h2><blockquote><blockquote><p>给定一个主串S，以及一个模式串P，所有字符串中只包含大小写英文字母以及阿拉伯数字。<br>模式串P在主串S中多次作为子串出现。<br>求出模式串P在主串S中所有出现的位置的起始下标。<br><strong>输入格式</strong><br>第一行输入整数N，表示字符串P的长度。<br>第二行输入字符串P。<br>第三行输入整数M，表示字符串S的长度。<br>第四行输入字符串S。<br><strong>输出格式</strong><br>共一行，输出所有出现位置的起始下标（下标从0开始计数），整数之间用空格隔开。<br><strong>数据范围</strong><br>$1≤N≤10^5$<br>$1≤M≤10^6$<br><strong>输入样例：</strong><br>3<br>aba<br>5<br>ababa<br><strong>输出样例：</strong><br>0 2  </p></blockquote></blockquote><p>首先我们都会考虑朴素做法：利用双指针算法，对于每一个字符尝试匹配。</p><pre><code class="line-numbers language-cpp">for(int i = 1; i &lt;= n -m; i++)&#123;    bool flag = true;    for(int j = 1; j &lt;= m ; j++)    if(s[i + j - 1] != p[j])    &#123;        flag = false;        break;//对于本题再记录一下下标即可。    &#125;&#125;</code></pre><p>朴素算法的时间复杂度为$0(mn)$。<br>考虑优化：朴素做法时间效率低下的原因是每次匹配失败后完全“从头来过”，完全不利用“残留的信息”。<br>那么如何利用所谓的“残留的信息”?<br>有这样一种情况：对于当前匹配<strong>成功的部分</strong>,如果这部分与<strong>自身</strong>匹配也有<strong>成功的部分</strong> *(这里成功的部分不包括这部分整个，毕竟自身与自身匹配一定成功，但是没有意义)*，那么说明当对于模式串的整体虽然匹配失败了，但是匹配成功的部分可以通过移动，来继续尝试完成匹配。</p><p>看一个栗子！：</p><h2 id="示例-Example"><a href="#示例-Example" class="headerlink" title="示例(Example)"></a>示例(Example)</h2><p><img src="https://i.loli.net/2021/07/14/Id2egC4QVbUmvPw.jpg" alt="KMP示例1"></p><p>当主串中第i个字符，与模式串中第j个字符匹配失败，但是有<strong>成功的部分</strong>为$ababab$，且$ababab$有最长的成功的部分$abab$。那么只要移动两格能继续匹配：主串第i个字符与模式串第j-2个字符匹配。(相当于模式串的匹配点左移了)<br>受次启发，对于更一般的：<br>当主串第i个字符与模式串第j个字符匹配失败时，假设经过移动后，主串中第i个字符继续与模式串第k个字符匹配(k &lt; j),那么此时模式串前k - 1个字母与主串i前面k - 1个字母完成匹配。<br>因而有关系：$p_1p_2…p_{k-1} = s_{i-(k-1)}s_{i-(k-2)}…s_{i-1}$.<br>并且k为所有满足条件的最大k(也就是说这是最长的<strong>成功的部分</strong>)<br>而我们已经有之前匹配完成的部分：<br>$p_{j - (k - 1)}p_{j-(k-2)}…p_{j-1} = s_{i-(k-1)}s_{i-(k-2)}…s_{i-1}$<br>对比两式可得：$p_1p_2…p_{k-1}$ =$p_{j - (k - 1)}p_{j-(k-2)}…p_{j-1}$ (这就是成功部分中最长的<strong>成功的部分</strong>对应的等式)。(无心套娃)<br>(康康图)</p><h2 id="示例-Example-1"><a href="#示例-Example-1" class="headerlink" title="示例(Example)"></a>示例(Example)</h2><p><img src="https://i.loli.net/2021/07/14/1Dp6G3KwTd2Vamv.jpg" alt="KMP示例2"></p><p>因此，如果模式串中存在满足最后一个式子的字符，便可做以上优化。<br>我们利用数组$ne[j] = k$,表示模式串中第j个字符与主串对应字符匹配失败时，模式串中能够通过移动，利用<strong>成功的部分</strong>继续完成匹配的字符的位置。<br>有如下定义：  </p><ol><li><p>$ne[1] = 0$，表示第一个字符就匹配失败了，退无可退。</p></li><li><p>当不存在<strong>成功部分自身的成功部分</strong>时，$ne[j] = 1$，重新开始比较。  </p></li><li><p>$ne[j] = max k$ ，k表示<strong>成功的部分的长度</strong>;<br> 这样，如果我们成功造出了ne[]数组，那么每次的匹配就能通过ne[]的迭代快速找到继续匹配的机会，或者直接下一轮。  </p></li></ol><table><thead><tr><th>$j$</th><th>$p_j$</th><th>$ne[j]$</th></tr></thead><tbody><tr><td>1</td><td>a</td><td>0</td></tr><tr><td>2</td><td>b</td><td>1</td></tr><tr><td>3</td><td>c</td><td>1</td></tr><tr><td>4</td><td>a</td><td>1</td></tr><tr><td>5</td><td>b</td><td>2</td></tr><tr><td>6</td><td>c</td><td>3</td></tr><tr><td>7</td><td>d</td><td>4</td></tr><tr><td>8</td><td>a</td><td>1</td></tr><tr><td>9</td><td>b</td><td>2</td></tr><tr><td>10</td><td>c</td><td>3</td></tr><tr><td>11</td><td>d</td><td>4</td></tr><tr><td>12</td><td>e</td><td>1</td></tr></tbody></table><p>  假设我们完成了ne[]的建造，那么代码就可以这样写了:</p><h2 id="代码实现-Code"><a href="#代码实现-Code" class="headerlink" title="代码实现(Code)"></a>代码实现(Code)</h2><pre><code class="line-numbers language-cpp">for(int i = 1, j = 0;i &lt;= m ;i++)&#123;    while(j&amp;&amp;s[i] != p[j + 1])j = ne[j];    if(s[i] == p[j + 1])j++;    if(j == n)    &#123;        cout&lt;&lt;i - n &lt;&lt;&quot; &quot;;        j = ne[j];    &#125;&#125;</code></pre><p>那么问题又又来了ne[]数组怎么建？<br>嗯，我们知道ne[]数组取决于模式串本身，和主串没什么关系。我们可以从定义出发，通过递推来求ne[]。<br>首先j = 1时，ne[1] = 0,前面已经给出了，表示第一个就匹配失败了，直接重新开始匹配。<br>j &gt; 1时,令ne[j] = k，表明模式串$1\sim j-1$子串中存在一部分具有<strong>成功的部分</strong>,且<strong>最大长度</strong>为$k$。等价于有等式：  $p_1p_2…p_{k-1} =p_{j - (k - 1)}p_{j-(k-2)}…p_{j-1}$.<br>如果 $p_k = p_j$,那么等式延长为：  $p_1p_2…p_{k-1}p_k=p_{j - (k - 1)}p_{j-(k-2)}…p_{j-1}p_j$，<br>表明模式串1~j的最大子串(<strong>成功的部分</strong>）以此类推，直到使等式延长的条件不满足，即不存在$p_k = p_j$。<br>有递推式:$ne[j + 1] = k + 1 = ne[j] + 1$;<br>当等式延长条件不满足了，我们自然有：$p_k ≠ p_j$.<br>此时可以把求$ne[]$值的问题看成<strong>模式串本身进行匹配，并且匹配到了不成功的部分</strong>那么问题又回到了匹配本身：当匹配不成功时，我们又要研究<strong>成功的部分</strong>(这是这题自己在套娃了！)<br>现在已经有：$p_{j-(k-1)} = p_1,p_{j-(k-2)} = p_2,…,p_j = p_{k-1}$，此时应该将模式串滑动到<strong>用模式串中第$ne[k]$个字符与“主串”(这里也模式串)中的第j个字符相比较</strong>。<br>如果令$ne[k] = k’$,则有$p_{k’} = p_j$,说明此时在模式串中第$j+1$个字符之前存在一个长度为k’的最长<strong>成功的部分</strong>，这段长度与从模式串中从首字母起，长度为k’的子串相等。<br>有：$p_1p_2…p_{k’} = p_{j-(k’-1)}p_{j-(k’-2)}…p_j (1&lt;k’&lt;k&lt;j) $.<br>由此可得$ne[j + 1] = k’ + 1 = ne[ne[j]] + 1$;<br>这里比较难理解，看一个例子：  </p><h2 id="示例-Example-2"><a href="#示例-Example-2" class="headerlink" title="示例(Example)"></a>示例(Example)</h2><p><img src="https://i.loli.net/2021/07/14/Ivt1roQHLnqMfVj.jpg" alt="KMP示例3"></p><p>同理，如果$p_{k’} ≠ p_j$,那么模式串继续向右滑动，使得模式串第ne[k’] (也就是ne[ne[k]])个字符与$p_j$对齐，如此反复。<br>会有两种结局：  </p><ol><li>直到$p_j$和模式串某个字符匹配成功。</li><li>不存在任何一个k’满足：<br>$p_1p_2…p_{k’} = p_{j-(k’-1)}p_{j-(k’-2)}…p_j (1&lt;k’&lt;k&lt;j) $，那么$ne[k + 1] = 1$;<br>至此我们可以实现$ne[]$代码：  </li></ol><h2 id="代码实现-Code-1"><a href="#代码实现-Code-1" class="headerlink" title="代码实现(Code)"></a>代码实现(Code)</h2><pre><code class="line-numbers language-cpp">for(int i = 2, j = 0;i &lt;= n ;i++)&#123;//i从2开始，因为从1开始，自身必然完全匹配自身，没意义。    while(j&amp;&amp;p[i] != p[j + 1])j = ne[j];    if(p[i] == p[j + 1])j++;    ne[i] = j;&#125;</code></pre><p>求ne[]的理论虽然复杂，但是代码和主串与模式串匹配的代码十分相似，其实本质上都是两个串的匹配。</p><hr><p>关于优化KMP和拓展KMP暂时保留，因为KMP本身就需要好好理解，多了反而不好。(我也不会)</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列(Queue)</title>
      <link href="/2021/07/14/"/>
      <url>/2021/07/14/</url>
      
        <content type="html"><![CDATA[<h2 id="简介-Introduction"><a href="#简介-Introduction" class="headerlink" title="简介(Introduction)"></a>简介(Introduction)</h2><blockquote><blockquote><p>队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。</p></blockquote></blockquote><h2 id="描述-Description"><a href="#描述-Description" class="headerlink" title="描述(Description)"></a>描述(Description)</h2><p>队列是一种<strong>先进先出</strong>的结构，可以想象为平时人们的排队打饭。先排队的人一定是在队列的前面，就会先打饭，先离开。反之，后来排队的人自然也后打饭，后离开。</p><p>队列的实现也比较好理解，直接上基本操作的代码：</p><h2 id="代码实现-Code"><a href="#代码实现-Code" class="headerlink" title="代码实现(Code)"></a>代码实现(Code)</h2><ol><li><p>向队尾插入一个元素</p><pre><code class="line-numbers language-cpp">void push(int x)&#123; q[++tt] = x;//tt表示队尾，初始为-1&#125;</code></pre></li><li><p>从队头弹出一个元素</p><pre><code class="line-numbers language-cpp">void pop()&#123; hh++;&#125;</code></pre></li><li><p>判断是否队空</p><pre><code class="line-numbers language-cpp">bool empty()&#123; if(hh &lt;= tt)return false ; else return true;&#125;</code></pre></li><li><p>查询队头元素</p><pre><code class="line-numbers language-cpp">int query()&#123; return q[hh];&#125;</code></pre><h2 id="应用：单调队列"><a href="#应用：单调队列" class="headerlink" title="应用：单调队列"></a>应用：单调队列</h2><blockquote><blockquote><p>给定一个大小为$n≤10^6$的数组。<br>有一个大小为k的滑动窗口，它从数组的最左边移动到最右边。<br>您只能在窗口中看到k个数字。<br>每次滑动窗口向右移动一个位置。<br>您的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。<br><strong>输入格式</strong><br>输入包含两行。<br>第一行包含两个整数n和k，分别代表数组长度和滑动窗口的长度。<br>第二行有n个整数，代表数组的具体数值。<br>同行数据之间用空格隔开。<br><strong>输出格式</strong><br>输出包含两个。<br>第一行输出，从左至右，每个位置滑动窗口中的最小值。<br>第二行输出，从左至右，每个位置滑动窗口中的最大值。<br><strong>输入样例：</strong><br>8 3<br>1 3 -1 -3 5 3 6 7<br><strong>输出样例：</strong><br>-1 -3 -3 -3 3 3<br>3 3 5 5 6 7  </p></blockquote></blockquote></li></ol><p>和单调栈类似，首先考虑暴力：对于每个“窗口”(队列)，通过遍历寻找队列中的最大值和最小值，然后输出。时间复杂度为$0(nk)$。大概率会超时的。<br>考虑和单调栈类似的单调性优化：<br>对于队列$[tt,hh]$中的所有元素寻找<strong>最小值</strong>，如果存在一组逆序对：$a_x ≥ a_y,x &lt; y $ 那么$a_x$的存在一定是不必要的。因此，整个队列的存在一定是<strong>单调上升</strong>的，最小值就是队头。</p><pre><code class="line-numbers language-cpp">for(int i = 0; i &lt; n ; i++)    &#123;//队列里面存的是数组的下标(要判断队长)，a[]存的是值        if(hh &lt;= tt &amp;&amp; q[hh] &lt; i- k + 1)hh++;//队长度为小于k        while(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i])tt--;//当有逆序        q[++tt] = i;//下标入队                if(i &gt;= k - 1)cout&lt;&lt;a[q[hh]]&lt;&lt;&quot; &quot;;//前k个数    &#125;</code></pre><p>寻找<strong>最大值</strong>通过类似的单调性思考即可。</p><hr><p>都是队列的基本操作，做了解。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表(Linked list)</title>
      <link href="/2021/07/13/"/>
      <url>/2021/07/13/</url>
      
        <content type="html"><![CDATA[<h2 id="简介-Introduction"><a href="#简介-Introduction" class="headerlink" title="简介(Introduction)"></a>简介(Introduction)</h2><blockquote><blockquote><p>链表是一种物理存储单元上非连续、非顺序的<strong>存储结构</strong>，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。</p></blockquote></blockquote><h2 id="描述-Description"><a href="#描述-Description" class="headerlink" title="描述(Description)"></a>描述(Description)</h2><p>由于结构体加指针类型的链表在开辟内存空间时运行速度很慢，这里只介绍利用<strong>数组模拟的链表</strong>(静态链表)。</p><h2 id="示例-Example"><a href="#示例-Example" class="headerlink" title="示例(Example)"></a>示例(Example)</h2><p><img src="https://i.loli.net/2021/07/13/hP1qeHp8d6Jf5Kn.jpg" alt="链表示例"></p><h1 id="单链表-Singly-Linked-List"><a href="#单链表-Singly-Linked-List" class="headerlink" title="单链表(Singly Linked List)"></a>单链表(Singly Linked List)</h1><p>单链表常见的操作：  </p><ol><li>初始化<h2 id="代码实现-Code"><a href="#代码实现-Code" class="headerlink" title="代码实现(Code)"></a>代码实现(Code)</h2><pre><code class="line-numbers language-cpp">int head, e[N],ne[N], idx;//初始化链表：void Init()&#123; head = -1; idx = 0;&#125;</code></pre></li><li>向表头插入一个数：</li></ol><h2 id="示例-Example-1"><a href="#示例-Example-1" class="headerlink" title="示例(Example)"></a>示例(Example)</h2><p><img src="https://i.loli.net/2021/07/13/1HUxfiW7tVM2NIc.jpg" alt="链表插入"></p><h2 id="代码实现-Code-1"><a href="#代码实现-Code-1" class="headerlink" title="代码实现(Code)"></a>代码实现(Code)</h2><pre><code class="line-numbers language-cpp">void add_to_head(int x)&#123;    e[idx] = x;    ne[idx] = head;    head = idx++;&#125;</code></pre><ol start="3"><li>在第k个数后面插入一个数</li></ol><h2 id="代码实现-Code-2"><a href="#代码实现-Code-2" class="headerlink" title="代码实现(Code)"></a>代码实现(Code)</h2><pre><code class="line-numbers language-cpp">void add(int k, int x)&#123;    e[idx] = x;    ne[idx] = ne[k];    ne[k] = idx++;&#125;</code></pre><ol start="4"><li>删除第k个插入的数的后面一个数：</li></ol><h2 id="示例-Example-2"><a href="#示例-Example-2" class="headerlink" title="示例(Example)"></a>示例(Example)</h2><p><img src="https://i.loli.net/2021/07/13/tu7HDeTvQ5iqnaW.jpg" alt="链表删除"></p><h2 id="代码实现-Code-3"><a href="#代码实现-Code-3" class="headerlink" title="代码实现(Code)"></a>代码实现(Code)</h2><pre><code class="line-numbers language-cpp">void del(int k)//注意传入时要传k - 1;&#123;    ne[k] = ne[ne[k]];&#125;</code></pre><ol start="5"><li>删除头结点</li></ol><h2 id="代码实现-Code-4"><a href="#代码实现-Code-4" class="headerlink" title="代码实现(Code)"></a>代码实现(Code)</h2><pre><code class="line-numbers language-cpp">head = ne[head];</code></pre><hr><h1 id="双链表-Dual-Linked-List"><a href="#双链表-Dual-Linked-List" class="headerlink" title="双链表(Dual Linked List)"></a>双链表(Dual Linked List)</h1><p>双链表没有单链表常用，因为各种操作稍微复杂。<br>直接给出代码和一点解释：</p><h2 id="代码实现-Code-5"><a href="#代码实现-Code-5" class="headerlink" title="代码实现(Code)"></a>代码实现(Code)</h2><ol><li>初始化</li></ol><pre><code class="line-numbers language-cpp">  int l[N],r[N],e[N];//左右指针和值int cnt=0;void Init()&#123;    //0表示左端点，1表示右端点    r[0]=1,l[1]=0;//一开始左右互指    cnt=1; //cnt从1开始&#125;</code></pre><ol start="2"><li><p>在第k个插入的点右边插入值为x的点(右插)(传入k + 1)</p><pre><code class="line-numbers language-cpp">void add_r(int k,int x)&#123; e[++cnt]=x;//计数器加一并且存值 r[cnt]=r[k]; l[cnt]=k； l[r[k]]=cnt; r[k]=cnt; //注意一定要先改变r[k]的左指针，再改变r[k] //一旦先改变r[k]，那么r[k]的左指针就失效了。</code></pre></li><li><p>在第k个插入的点左边插入值为x的点(左插)(传入k + 1)<br>直接调用</p><pre><code class="line-numbers language-cpp">add_r(l[k],x);//第k个点左边插入等价于在第k个点的左边一个点的右边插入。//当然，模仿又插再写一个也行。</code></pre></li><li><p>删除第k个插入的点(传入 k + 1)</p><pre><code class="line-numbers language-cpp">void del(int k)&#123; r[l[k]]=r[k]; l[r[k]]=l[k];&#125;</code></pre></li></ol><hr><p>这些都是链表的基本操作，尤其是单链表要熟练掌握。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈(Stack)</title>
      <link href="/2021/07/13/"/>
      <url>/2021/07/13/</url>
      
        <content type="html"><![CDATA[<h2 id="简介-Introduction"><a href="#简介-Introduction" class="headerlink" title="简介(Introduction)"></a>简介(Introduction)</h2><blockquote><blockquote><p>栈（stack）又名堆栈，它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。</p></blockquote></blockquote><h2 id="描述-Description"><a href="#描述-Description" class="headerlink" title="描述(Description)"></a>描述(Description)</h2><p>栈是一种<strong>先进后出</strong>结构，可以想象成一个桶里放盘子，最先放进去的盘子一定最后拿出来，而后放入的盘子先拿出来。</p><p>栈的实现比较好理解，就不做示例了。直接上基本操作的代码：</p><h2 id="代码实现-Code"><a href="#代码实现-Code" class="headerlink" title="代码实现(Code)"></a>代码实现(Code)</h2><ol><li><p>入栈</p><pre><code class="line-numbers language-cpp">void push(int x)&#123; stk[++tt] = x;//tt一开始为0&#125;</code></pre></li><li><p>出栈</p><pre><code class="line-numbers language-cpp">voide pop()&#123; tt--;&#125;</code></pre></li><li><p>判断是否栈空</p><pre><code class="line-numbers language-cpp">bool empty()&#123; if(tt == 0) return true; else return false;&#125;</code></pre></li><li><p>查询栈顶元素</p><pre><code class="line-numbers language-cpp">int query()&#123; return stk[tt];&#125;</code></pre></li></ol><hr><h2 id="应用：单调栈"><a href="#应用：单调栈" class="headerlink" title="应用：单调栈"></a>应用：单调栈</h2><blockquote><blockquote><p>给定一个长度为N的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出-1。<br><strong>输入格式</strong><br>第一行包含整数N，表示数列长度。<br>第二行包含N个整数，表示整数数列。<br><strong>输出格式</strong><br>共一行，包含N个整数，其中第i个数表示第i个数的左边第一个比它小的数，如果不存在则输出-1。<br><strong>数据范围</strong><br>$1≤N≤10^5$<br>$1≤$数列中元素$≤10^9$<br><strong>输入样例：</strong><br>5<br>3 4 2 7 5<br><strong>输出样例：</strong><br>-1 3 -1 2 2</p></blockquote></blockquote><p>首先可以想到暴力做法：i指针遍历整个数组，j指针每次遍历i左边的所有数，如果存在则输出第一个数，不存在则输出-1。</p><pre><code class="line-numbers language-cpp">for(int i = 0; i &lt; n ; i++)    &#123;        bool flag = false;        for(int j = i - 1; j&gt;= 0 ;j--)        &#123;            if(a[j] &lt; a[i])            &#123;                cout&lt;&lt; a[j]&lt;&lt;&quot; &quot;;                flag = true;                break;            &#125;        &#125;        if(!flag)cout&lt;&lt;-1&lt;&lt;&quot; &quot;;    &#125;</code></pre><p>但是很不幸，这样会超时。那么考虑性质：<br>设栈中元素为$a_i$,如果有：$a_3 ≥ a_5$，那么$a_3$的存在一定是不必要的，因为对于$a_5$后面的元素$a_x$，如果$a_3 &lt; a_x$,那么也一定有$a_5 &lt; a_x$,并且$a_5$距$a_x$更近。<br>那么对于一般的：如果栈中存在：$a_x ≥ a_y,x &lt; y$,那么可以删去$a_x$，所以剩下的序列一定是单调的。</p><p>因此有下面的解：</p><pre><code class="line-numbers language-cpp">for(int i = 0 ; i &lt; n ; i++)    &#123;        int x;         cin&gt;&gt;x;        while(tt &amp;&amp; stk[tt] &gt;= x)tt--;//如果栈不空，且栈顶大于当前元素，那么栈顶再也不会用得到了，删去。        if(tt)cout&lt;&lt;stk[tt]&lt;&lt;&quot; &quot;;//如果栈不空，说明有合理解，输出        else cout &lt;&lt;&quot;-1&quot;&lt;&lt;&quot; &quot;;//栈空无解                stk[++tt] = x;//放入x    &#125;</code></pre><hr><p>都是栈基本的操作，做了解。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间合并(Merge Interval)</title>
      <link href="/2021/07/13/"/>
      <url>/2021/07/13/</url>
      
        <content type="html"><![CDATA[<h2 id="简介-amp-描述-Introduction-amp-Description"><a href="#简介-amp-描述-Introduction-amp-Description" class="headerlink" title="简介&amp;描述(Introduction&amp;Description)"></a>简介&amp;描述(Introduction&amp;Description)</h2><blockquote><blockquote><p>区间合并也是一种比较”狭窄”的算法，顾名思义，是用于把给定的、可以合并的区间合并。</p></blockquote></blockquote><h2 id="示例-Example"><a href="#示例-Example" class="headerlink" title="示例(Example)"></a>示例(Example)</h2><p>图示中有5个区间：$(1,2),(2,4),(5,6),(7,8),(7,9)$<br><img src="https://i.loli.net/2021/07/13/LOF4SdtuPyDJ7rT.jpg" alt="区间合并1"><br>合并之后成为3个区间：$(1,4),(5,6),(7,9)$</p><p><img src="https://i.loli.net/2021/07/13/DFgHNGwcetUmojq.jpg" alt="区间合并2"></p><h2 id="分析-Analysis"><a href="#分析-Analysis" class="headerlink" title="分析(Analysis)"></a>分析(Analysis)</h2><ol><li>不能碰见一个就遍历一次，效率太低，我们先将所有区间按照左端点从小到大进行排序。</li><li>排完序后，当前区间和下一个区间的关系有三种：<br> (1):下一个区间左右端点在当前区间内。<br> (2):下一个区间左端点在当前区间内，右端点在当前区间外。<br> (3):下一个区间左端点在当前区间外。<br> 对于(1),当前区间不用更新。<br> 对于(2),当前区间的右端点更新。<br> 对于(3),当前区间维护完毕，当前区间更新为下一个区间。<h2 id="代码实现-Code"><a href="#代码实现-Code" class="headerlink" title="代码实现(Code)"></a>代码实现(Code)</h2><pre><code class="line-numbers language-cpp">void merge(vector&lt;pair&lt;int,int&gt;&gt; &amp;itvs)&#123;vetor&lt;pair&lt;int,int&gt;&gt; res;//用来临时存合并后的区间sort(itvs.begin(),itvs.end());//排序int st = -2e9, ed = -2e9;//无穷小初始化for(auto itv : itvs)&#123; if(ed &lt; itv.first)//情况(3) &#123;   if(st != -2e9)res.push_back(&#123;st,ed&#125;);   st = itv.first,ed = itv.second; &#125; else ed = max(ed, itv.second);//情况(1)、(2)&#125;if(st!= -2e9)res.push_back(&#123;st,ed&#125;);//最后一组放入itvs = res;//还给itvs&#125;</code></pre></li></ol><hr><p>区间合并比较小众，记住就行了。</p>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区间合并 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散化(Discretization)</title>
      <link href="/2021/07/12/"/>
      <url>/2021/07/12/</url>
      
        <content type="html"><![CDATA[<h2 id="简介-Introduction"><a href="#简介-Introduction" class="headerlink" title="简介(Introduction)"></a>简介(Introduction)</h2><blockquote><blockquote><p>离散化，把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。<br>通俗的说，离散化是在不改变数据相对大小的条件下，对数据进行相应的缩小。</p></blockquote></blockquote><h2 id="描述-Description"><a href="#描述-Description" class="headerlink" title="描述(Description)"></a>描述(Description)</h2><p>离散化用于处理一些个数不多，但是数据本身很大但是仍需要作为数组等无法过大的下标时，我们可以处理一下这些大的下标，并且依然保持其原序。</p><h2 id="示例-Example"><a href="#示例-Example" class="headerlink" title="示例(Example)"></a>示例(Example)</h2><p><img src="https://i.loli.net/2021/07/12/hxvcRIXkzZAB96f.jpg" alt="位运算示例"></p><p>然而这个示例好像并没有什么用诶。</p><h2 id="细节-Detail"><a href="#细节-Detail" class="headerlink" title="细节(Detail)"></a>细节(Detail)</h2><ol><li>注意去重复元素。</li><li>如何快速保序映射？</li></ol><h2 id="代码实现-Code"><a href="#代码实现-Code" class="headerlink" title="代码实现(Code)"></a>代码实现(Code)</h2><p>首先来完成去重操作:</p><pre><code class="line-numbers language-cpp"># include &lt;algorithm&gt;sort(a.begin(),a.end());//首先排序://然后去重a.erase(unique(a.begin(),a.end()),a.end());</code></pre><p>第一步完成了，那么第二步快速映射也很轻松有二分查找：</p><pre><code class="line-numbers language-cpp">int find(int x)&#123;  int l = 0 , r = a.size() -1;  while(l &lt; r)  &#123;    int mid = l + r &gt;&gt;1;    if(a[mid] &gt;= x)r = mid;    else l = mid + 1;  &#125;  return l +1;//从1~n的映射。&#125;</code></pre><hr><h2 id="应用：区间和"><a href="#应用：区间和" class="headerlink" title="应用：区间和"></a>应用：区间和</h2><blockquote><blockquote><p>假定有一个无限长的数轴，数轴上每个坐标上的数都是0。<br>现在，我们首先进行 n 次操作，每次操作将某一位置x上的数加c。<br>接下来，进行 m 次询问，每个询问包含两个整数l和r，你需要求出在区间[l, r]之间的所有数的和。<br><strong>输入格式</strong><br>第一行包含两个整数n和m。<br>接下来 n 行，每行包含两个整数x和c。<br>再接下里 m 行，每行包含两个整数l和r。<br><strong>输出格式</strong><br>共m行，每行输出一个询问中所求的区间内数字和。<br><strong>数据范围</strong><br>$-10^9≤x≤10^9$,<br>$1≤n,m≤10^5$,<br>$−10^9≤l≤r≤10^9$,<br>$−10000≤c≤10000$<br>输入样例：<br>3 3<br>1 2<br>3 6<br>7 5<br>1 3<br>4 6<br>7 8<br>输出样例：<br>8<br>0<br>5</p></blockquote></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>由于坐标数据范围很大，但是数据量较小，考虑离散化处理所有坐标。<br>最后要求区间和，可以使用前缀和来求。</p><hr><p>离散化虽然简单，却是比较实用的一种方法。</p>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 离散化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算(Bitwise operation)</title>
      <link href="/2021/07/12/"/>
      <url>/2021/07/12/</url>
      
        <content type="html"><![CDATA[<h2 id="简介-Introduction"><a href="#简介-Introduction" class="headerlink" title="简介(Introduction)"></a>简介(Introduction)</h2><blockquote><blockquote><p>程序中的所有数在计算机内存中都是以二进制的形式储存的。位运算就是直接对整数在内存中的二进制位进行操作。</p></blockquote></blockquote><h2 id="描述-Description"><a href="#描述-Description" class="headerlink" title="描述(Description)"></a>描述(Description)</h2><p>位运算是计算机内的一种最基本的运算方式，快捷高效。又是一个小知识点。运算的逻辑是先将两个操作数转化成二进制数，然后做位运算。</p><table><thead><tr><th align="left">运算符</th><th align="left">名称</th></tr></thead><tbody><tr><td align="left">&amp;</td><td align="left">按位“与”</td></tr><tr><td align="left">丨</td><td align="left">按位“或”</td></tr><tr><td align="left">^</td><td align="left">按位“异或”</td></tr><tr><td align="left">~</td><td align="left">取反</td></tr><tr><td align="left">&lt;&lt;</td><td align="left">左移</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">右移</td></tr></tbody></table><p>具体运算规律如下：</p><h2 id="示例-Example"><a href="#示例-Example" class="headerlink" title="示例(Example)"></a>示例(Example)</h2><table><thead><tr><th align="left">A</th><th align="left">B</th><th align="left">~A</th><th align="left">A丨B</th><th align="left">A&amp;B</th><th align="left">A^B</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">0</td></tr><tr><td align="left">对于&lt;&lt;和&gt;&gt;运算，在数据可以表达的范围内，a&lt;&lt;k相当于$a×2^k$，而a&gt;&gt;k相当于$a / 2^k$。</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><h2 id="细节-Detail"><a href="#细节-Detail" class="headerlink" title="细节(Detail)"></a>细节(Detail)</h2><ol><li>位运算的操作对象只能是整型或者字符型数据。</li><li>操作数的位移运算不改变原数的值。</li></ol><hr><h2 id="应用：二进制中1的个数"><a href="#应用：二进制中1的个数" class="headerlink" title="应用：二进制中1的个数"></a>应用：二进制中1的个数</h2><p>（重点当然是记住简约而不简单的应用啦)</p><blockquote><blockquote><p>给定一个长度为n的数列，请你求出数列中每个数的二进制表示中1的个数。<br><strong>输入格式</strong><br>第一行包含整数n。<br>第二行包含n个整数，表示整个数列。<br><strong>输出格式</strong><br>共一行，包含n个整数，其中的第 i 个数表示数列中的第 i 个数的二进制表示中1的个数。<br><strong>数据范围</strong><br>$1≤n≤100000$,<br>$0≤数列中元素的值≤10^9$<br><strong>输入样例：</strong><br>5<br>1 2 3 4 5<br><strong>输出样例：</strong><br>1 1 2 1 2  </p></blockquote></blockquote><p>先来看一个祖传操作：lowbit</p><pre><code class="line-numbers language-cpp">int lowbit(x)&#123;  return x &amp; -x;&#125;</code></pre><p>该函数返回x二进制下最后一位1的位置对应的值。(这么说可能不太明白，上图吧。)</p><h2 id="示例-Example-1"><a href="#示例-Example-1" class="headerlink" title="示例(Example)"></a>示例(Example)</h2><p><img src="https://i.loli.net/2021/07/12/3DrIvT6MQWEmOqF.jpg" alt="位运算示例"></p><p>有了这样一个神奇的操作后这题也就解决了大半。<br>再附上一个本题的另一小半核心代码：</p><pre><code class="line-numbers language-cpp">while(x)x - lowbit(x),res++;</code></pre><p>这样本题也就解决啦~</p><p>当然还有一个简单的操作也可以记一下：求n的第k位二进制数字:</p><pre><code class="line-numbers language-cpp">int findk(int n , int k)&#123;  return n &gt;&gt; k &amp; 1;&#125;</code></pre><hr><p>位运算为之后的状压准备，lowbit为后面的树状数组做准备。</p>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针算法</title>
      <link href="/2021/07/12/"/>
      <url>/2021/07/12/</url>
      
        <content type="html"><![CDATA[<h2 id="简介-Introduction"><a href="#简介-Introduction" class="headerlink" title="简介(Introduction)"></a>简介(Introduction)</h2><blockquote><blockquote><p>双指针算法是一种广泛运用的基础算法,在很多地方都有应用。<strong>其核心用处是对于朴素的算法做优化。</strong></p></blockquote></blockquote><h2 id="描述-Description"><a href="#描述-Description" class="headerlink" title="描述(Description)"></a>描述(Description)</h2><p>双指针算法在很多地方都有应用，只是很多时候我们没有意识到自己正在用。如快速排序、归并排序中都用到了双指针算法。</p><h2 id="代码实现-Code"><a href="#代码实现-Code" class="headerlink" title="代码实现(Code)"></a>代码实现(Code)</h2><p>双指针算法与其说是一种算法，不如说是一种处理问题的方式，要具体问题具体分析。所以代码实现并不是那么重要。</p><pre><code class="line-numbers language-cpp">for(int i = 0 ; j= 0 ; i &lt; n ; i ++)&#123;  while(j &lt; i &amp;&amp; check(i,j))j++;  //具体的题目具体分析&#125;</code></pre><hr><h2 id="应用：最长连续不重复子序列"><a href="#应用：最长连续不重复子序列" class="headerlink" title="应用：最长连续不重复子序列"></a>应用：最长连续不重复子序列</h2><blockquote><blockquote><p>给定一个长度为n的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。<br><strong>输入格式</strong><br>第一行包含整数n。<br>第二行包含n个整数（均在0~100000范围内），表示整数序列。<br><strong>输出格式</strong><br>共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。<br><strong>数据范围</strong><br>1≤n≤100000<br><strong>输入样例：</strong><br>5<br>1 2 2 3 5<br><strong>输出样例：</strong><br>3  </p></blockquote></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这题首先可以想到一个朴素的做法：利用两重for循环暴力求解，其时间复杂度为$O(n^2)$。<br>考虑单调性优化：前后指针的移动是有相互关联的。当前后指针分别指向当前位置的<strong>最长不重复段</strong>，前指针向后移动时，后指针也一定会向后移动。这样时间复杂度就可以优化为$O(n)$。</p><h2 id="核心代码-Code"><a href="#核心代码-Code" class="headerlink" title="核心代码(Code)"></a>核心代码(Code)</h2><pre><code class="line-numbers language-cpp">for(int i = 0 , j = 0 ; i &lt; n ; i++)//循环i&#123;  s[a[i]]++;//前指针做记录  while(s[a[i]] &gt; 1)//大于1说明出现重复  &#123;    s[a[j]]--;//去掉重复，知道条件不成立    j++;  &#125;  res = max(res, i - j + 1);//取最长不重复区间长。&#125;</code></pre><h2 id="示例-Example"><a href="#示例-Example" class="headerlink" title="示例(Example)"></a>示例(Example)</h2><h2 id><a href="#" class="headerlink" title></a><img src="https://i.loli.net/2021/07/12/aOVuwkNEL91grhq.jpg" alt="演示双指针"></h2><hr><p>双指针就这样水过去吧！这种还是得多做题。</p>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>差分(Adjacent_difference)</title>
      <link href="/2021/07/11/"/>
      <url>/2021/07/11/</url>
      
        <content type="html"><![CDATA[<h2 id="简介-Introduction"><a href="#简介-Introduction" class="headerlink" title="简介(Introduction)"></a>简介(Introduction)</h2><blockquote><blockquote><p>差分与前缀和相对，可以视为前缀和的逆运算。差分它可以维护多次对序列的一个区间修改一个数。</p></blockquote></blockquote><h2 id="一维差分示例-Example"><a href="#一维差分示例-Example" class="headerlink" title="一维差分示例(Example)"></a>一维差分示例(Example)</h2><p>数列：</p><blockquote><p>$\begin{matrix} 2&amp;3&amp;5&amp;7&amp;11&amp;13&amp;17&amp;19\end{matrix}$</p></blockquote><p>差分处理之后：</p><blockquote><p>$\begin{matrix} 2&amp;1&amp;2&amp;2&amp;4&amp;2&amp;4&amp;2\end{matrix}$</p></blockquote><p>可以看到，差分后的数列用前缀和处理后可以得到：</p><blockquote><p>$\begin{matrix} 2&amp;3&amp;5&amp;7&amp;11&amp;13&amp;17&amp;19\end{matrix}$</p></blockquote><p>即为原数列。<br>通常情况下我们也并不关心差分后的结果，只关心差分并处理最后再前缀和后的结果。</p><h2 id="代码实现-Code"><a href="#代码实现-Code" class="headerlink" title="代码实现(Code)"></a>代码实现(Code)</h2><pre><code class="line-numbers language-cpp">void adjdif(int a[], int b[],int n)&#123;  for(int i = 1; i &lt;= n ;i++)  b[i] = a[i] - a[i -1];&#125;</code></pre><p>和前缀和对应的，c++标准库中也实现了差分函数：</p><pre><code class="line-numbers language-cpp"># include &lt;numeric&gt;std::adjacent_difference(a, a + n, b);</code></pre><p>利用差分后再做前缀和可以得到原数列的性质，可以通过改变差分后的数组从而改变原数组。</p><pre><code class="line-numbers language-cpp">void Insert(int b[], int c)&#123;  b[1] += c;&#125;</code></pre><p>该函数使差分数组的第一个元素加上了常数$c$,可以想到，在做前缀和处理，回到原数组的时候，由递推公式为：$a[i] = a[i -1] + b[i];$，可以得到原数组所有的元素都将加上$c$。<br>再通过这个性质，做一点变形，有：</p><pre><code class="line-numbers language-cpp">void Insert(int b[],int l ,int r, int c)&#123;//l在r的左边(或重合)  b[l] += c;  b[r + 1] -=c;&#125;</code></pre><p>不难理解，该函数可以将原数组$[l,r]$部分的每个元素都加上常数$c$。    </p><p>基于此，我们甚至可以使用全初始化为0的数组来初始化原数组。只要把区间$[l,r]$缩小到每一个元素(l和r重合时)，根据<strong>函数可以将原数组$[l,r]$部分每个元素都加上c</strong>可以将一个元素赋予要赋的值。</p><p>所以所有的操作可以直接从差分数组本身开始，而不必用原数组做差分后操作，最后再前缀和。</p><h2 id="二维差分示例-Example"><a href="#二维差分示例-Example" class="headerlink" title="二维差分示例(Example)"></a>二维差分示例(Example)</h2><p>通过一维前缀和的启发，我们知道第一个差分操作是不必要的。初始化与修改都可以在差分数组中得到。二维也同理。<br>只要有类似的$Insert$函数即可。这里先给出代码，后给出解释。</p><h2 id="实现代码-Code"><a href="#实现代码-Code" class="headerlink" title="实现代码(Code)"></a>实现代码(Code)</h2><pre><code class="line-numbers language-cpp">void Insert(int x1, int x2, int y1, int y2, int c)&#123;//点(x1,y1) 在 (x2,y2)的左上方(或重合)  b[x1][y1] +=c;  b[x2 + 1][y2] -= c;  b[x2][y2 + 1] -= c;  b[x2][y2] +=c;&#125;</code></pre><h2 id="示例-Example"><a href="#示例-Example" class="headerlink" title="示例(Example)"></a>示例(Example)</h2><p><img src="https://i.loli.net/2021/07/11/YQJo1jGzCyStwE2.jpg" alt="二维差分示例"></p><p>由图不难得到代码中的操作公式~</p><hr><p>以上是一维、二维差分的板子，记下就行啦~<br>同样的，高维的和树相关的暂时还没学。</p>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 差分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和</title>
      <link href="/2021/07/11/"/>
      <url>/2021/07/11/</url>
      
        <content type="html"><![CDATA[<h2 id="简介-Introduction"><a href="#简介-Introduction" class="headerlink" title="简介(Introduction)"></a>简介(Introduction)</h2><blockquote><blockquote><p>前缀和是一种常用的、较为高效的预处理方式。能够有效降低查询的时间复杂度。前缀和可以理解为数组前$n$项的和。</p></blockquote></blockquote><h2 id="一维前缀和示例-Example"><a href="#一维前缀和示例-Example" class="headerlink" title="一维前缀和示例(Example)"></a>一维前缀和示例(Example)</h2><blockquote><p>数列：$\begin{matrix} 1&amp;2&amp;3&amp;4&amp;5 \end{matrix}$<br>前缀和处理后：$\begin{matrix}1&amp;3&amp;6&amp;10&amp;15\end{matrix}$</p></blockquote><h2 id="代码实现-Code"><a href="#代码实现-Code" class="headerlink" title="代码实现(Code)"></a>代码实现(Code)</h2><pre><code class="line-numbers language-cpp">void presum1(int a[],int s[],int n)&#123;  for(int i = 1; i&lt;= n ; i++)//为了不特判第一个元素，一般定义i从1开始，0号元素为0  s[i] = s[i -1] + a[i];&#125;</code></pre><p>在C++标准库中也实现了前缀和函数：</p><pre><code class="line-numbers language-cpp"># include &lt;numeric&gt;std::partial_sum(a, a + n, s);</code></pre><h2 id="二维前缀和示例-Example"><a href="#二维前缀和示例-Example" class="headerlink" title="二维前缀和示例(Example)"></a>二维前缀和示例(Example)</h2><p>对于矩阵a，可以视为一个数组:</p><blockquote><p>$\begin{matrix}<br>1&amp;2&amp;4&amp;3\<br>5&amp;6&amp;2&amp;4\<br>6&amp;3&amp;5&amp;9\<br>\end{matrix}$ </p></blockquote><p> 其前缀和为：</p><blockquote><p>$\begin{matrix}<br>1&amp;3&amp;7&amp;10\<br>6&amp;14&amp;20&amp;27\<br>12&amp;23&amp;34&amp;50\<br>\end{matrix}$</p></blockquote><h2 id="代码实现-Code-1"><a href="#代码实现-Code-1" class="headerlink" title="代码实现(Code)"></a>代码实现(Code)</h2><pre><code class="line-numbers language-cpp">void presum2(int a[][],int s[][],int n, int m)&#123;  for(int i = 1; i &lt;= n; i++)    for(int j = 1; j &lt;= m; j++)      s[i][j] = s[i][j -1] +  s[i -1][j] - s[i- 1][j -1] + a[i][j];&#125;</code></pre><h2 id="分析-Analysis"><a href="#分析-Analysis" class="headerlink" title="分析(Analysis)"></a>分析(Analysis)</h2><p>经过预处理之后每次查询的时间复杂度为$O(1)$。<br>一维前缀和比较容易理解，每次用第$i$项更新前缀和数组即可。<br>而二维前缀和的处理是基于<em>容斥原理</em>的。这里并不多介绍容斥原理，仅仅以下面的示例做简单说明。</p><h2 id="示例-Example"><a href="#示例-Example" class="headerlink" title="示例(Example)"></a>示例(Example)</h2><p><img src="https://i.loli.net/2021/07/11/lQvNa3nysiGCgpe.jpg" alt="二维前缀和示例"></p><p>最后得到递推公式为：</p><blockquote><p>$s[i][j] = s[i-1][j] + s[i][j-1] - s[i -1][j -1] + a[i][j]$.</p></blockquote><hr><p>前缀和板子，记住就行啦~</p>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高精度(High Accuracy)</title>
      <link href="/2021/07/11/"/>
      <url>/2021/07/11/</url>
      
        <content type="html"><![CDATA[<h2 id="简介-Introduction"><a href="#简介-Introduction" class="headerlink" title="简介(Introduction)"></a>简介(Introduction)</h2><blockquote><blockquote><p>高精度算法（High Accuracy Algorithm）是处理大数字的数学计算方法。在一般的科学计算中，会经常算到小数点后几百位或者更多，当然也可能是几千亿几百亿的大数字。一般这类数字我们统称为高精度数，高精度算法是用计算机对于超大数据的一种模拟加，减，乘，除，乘方，阶乘，开方等运算。</p></blockquote></blockquote><h2 id="描述-Description"><a href="#描述-Description" class="headerlink" title="描述(Description)"></a>描述(Description)</h2><p>对于某些需要用到超级大的数运算的题目，可以利用高精度算法来解决。高精度的处理是把数字以字符的形式储存在数组中，并且利用四则运算的性质来进行加减乘除运算。</p><h2 id="代码实现-Code"><a href="#代码实现-Code" class="headerlink" title="代码实现(Code)"></a>代码实现(Code)</h2><h3 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h3><pre><code class="line-numbers language-cpp">vector&lt;int&gt; sum(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;  vector&lt;int&gt;C;//储存答案用  if(A.size() &lt; B.size())return sum(B,A);  //保证函数中的数组“A”是较大数  int t = 0;//用于储存进位值  for(int i = 0; i &lt; A.size(); i++)  &#123;    t += A[i];    if(B.size() &gt; i)t += B[i];    C.push_back(i % 10);//模拟进位    i /= 10;  &#125;  if(t)C.push_back(1);//如果最后t补位0，表明最高位进了一位。  return C;&#125;</code></pre><h3 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h3><pre><code class="line-numbers language-cpp">vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;//默认已经处理使得传入的A大于B  vector&lt;int&gt;C;  int t = 0;  for(int i = 0; i &lt;A.size(); i++)  &#123;    t = A[i] - t;    if(B.size() &gt; i)t-=B[i];    C.push_back((t + 10) % 10)//模拟借位    if(t &lt; 0)t = 1;//发生借位    else t = 0;  &#125;  while(C.size() &gt; 1 &amp;&amp; C.back() == 0)  C.pop_back();//去掉前导0;  return C;&#125;</code></pre><h3 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h3><pre><code class="line-numbers language-cpp">vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b)&#123;//常见的高精乘法是一个大数乘一个小数  vector&lt;int&gt;C;  int t = 0;  for(int i = 0; i &lt; A.size()||t;i++)  &#123;//要么i没有循环完，要么t 不为0    if(i &lt; A.size())t += a[i] * b;    C.push_back(t % 10);    t /= 10;  &#125;  while(C.size() &gt; 1 &amp;&amp; C.back() == 0)  C.pop_back();//去掉前导0  return C;&#125;</code></pre><h3 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h3><pre><code class="line-numbers language-cpp">vector&lt;int&gt; div(vector&lt;int&gt; &amp;A,int b ,int &amp;r)&#123;//除法除了会返回商，还会返回一个余数r  r = 0;  vector&lt;int&gt;C;  int t = 0;  for(int i = A.size()- 1; i &gt;= 0 ; i--)  &#123;//除法是从最高位开始计算的，与另三个不同    r = r * 10 + A[i];    C.psuh_back(r / b);    r %= b;  &#125;  reverse(C.begin(), C.end());//翻转一下去除前导0  while(C.size() &gt; 1 &amp;&amp; C.back() == 0)  C.pop_back();  return C;&#125;</code></pre><hr><p>都是些模板，记下就行了。</p>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高精度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找(Binary Search)</title>
      <link href="/2021/07/10/"/>
      <url>/2021/07/10/</url>
      
        <content type="html"><![CDATA[<h2 id="简介-Introduction"><a href="#简介-Introduction" class="headerlink" title="简介(Introduction)"></a>简介(Introduction)</h2><blockquote><blockquote><p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。</p></blockquote></blockquote><h2 id="描述-Description"><a href="#描述-Description" class="headerlink" title="描述(Description)"></a>描述(Description)</h2><p>二分查找的前提是目标已近排好序。二分查找每次取半查找保证其高效率。</p><h2 id="示例-Example"><a href="#示例-Example" class="headerlink" title="示例(Example)"></a>示例(Example)</h2><ol><li>二分查找下界</li></ol><p>在目标数组中找3： </p><p><img src="https://i.loli.net/2021/07/10/KgzGUhaVTLY9AtP.jpg" alt="示例1"></p><p>在目标数组中找4：</p><p><img src="https://i.loli.net/2021/07/10/YqfVMgGBbL1lQv8.jpg" alt="示例2"></p><p>可见当找不到目标值时，会找到一个合适的，可以插入目标值的位置的下标。</p><ol start="2"><li>二分查找上界</li></ol><p>在目标数组中找3：  </p><p><img src="https://i.loli.net/2021/07/10/1hYGFRV4p3zwaDg.jpg" alt="示例3"></p><p>同理，如果找不到目标值，也会找到一个合适的、目标值可插入的位置。<br>通过上面演示可以得到：无论问题如何，<strong>二分查找本身一定可以找到一个“答案”。</strong></p><h2 id="代码实现-Code-整数二分"><a href="#代码实现-Code-整数二分" class="headerlink" title="代码实现(Code)(整数二分)"></a>代码实现(Code)(整数二分)</h2><pre><code class="line-numbers language-cpp">//寻找下界：int lower(int a[], int l, int r, int v)&#123;  int mid;  while(l &lt; r)  &#123;    mid = (l + r) /2;    if(a[mid] &gt;= v) r = mid;    else l = mid + 1;  &#125;  return l;&#125;//寻找上界：int upper(int a[], int l, int r, int v)&#123;  int mid;  while(l &lt; r)  &#123;    mid = (l + r)/ 2;    if(a[mid] &lt;= v)l = mid + 1;    else r = mid;  &#125;  return l;//如果存在目标值，返回的是目标值后一个值的下标，寻找目标值下标的话要 -1;&#125;</code></pre><h2 id="分析-Analysis"><a href="#分析-Analysis" class="headerlink" title="分析(Analysis)"></a>分析(Analysis)</h2><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>以寻找上界为例：<br>大小关系分析如下：  </p><ol><li>a[mid] = v:已经找到了一个符合条件的值，但是它的左边可能还有合适的值，继续向左找：r = mid;  </li><li>a[mid] &gt; v:要求的位置一定不在当前位置的后面，但是当前位置可能是答案(数组中没有目标值，并且当前位置是第一个大于目标值的位置)，所以向左找：r = mid;</li><li>a[mid] &lt; v:要求的位置一定不在当前位置以及当前位置的前面，所以向前找：l = mid + 1;</li></ol><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>二分查找的时间复杂度为$O(logn)$。</p><h2 id="细节-Detail"><a href="#细节-Detail" class="headerlink" title="细节(Detail)"></a>细节(Detail)</h2><p>函数返回上下界是受制于数组上下界的，如果目标值就在数组上界，那么也只会返回数组的上界，而不是目标值上界。</p><p><img src="https://i.loli.net/2021/07/10/BVA6WrYZlUjpFmQ.jpg" alt="示例4"></p><h2 id="补充-Supplement-浮点数二分"><a href="#补充-Supplement-浮点数二分" class="headerlink" title="补充(Supplement)(浮点数二分)"></a>补充(Supplement)(浮点数二分)</h2><p>相较于整数二分有复杂的边界问题，浮点数二分友善了很多。</p><pre><code class="line-numbers language-cpp">double Binary_search(double l, double r)&#123;  double mid;  while(r - l &gt; 1e-(k + 2))//k是题目要求的精确度  &#123;    mid = (l + r) / 2;    if(check())l = mid;    else r = mid;  &#125;  return l;&#125;</code></pre><hr><h2 id="应用：数的范围"><a href="#应用：数的范围" class="headerlink" title="应用：数的范围"></a>应用：数的范围</h2><blockquote><blockquote><p>给定一个按照升序排列的长度为n的整数数组，以及 q 个查询。<br>对于每个查询，返回一个元素k的起始位置和终止位置（位置从0开始计数）。<br>如果数组中不存在该元素，则返回“-1 -1”。<br><strong>输入格式</strong><br>第一行包含整数n和q，表示数组长度和询问个数。<br>第二行包含n个整数（均在1~10000范围内），表示完整数组。<br>接下来q行，每行包含一个整数k，表示一个询问元素。<br><strong>输出格式</strong><br>共q行，每行包含两个整数，表示所求元素的起始位置和终止位置。<br>如果数组中不存在该元素，则返回“-1 -1”。<br><strong>数据范围</strong><br>1≤n≤100000<br>1≤q≤10000<br>1≤k≤10000<br><strong>输入样例：</strong><br>6 3<br>1 2 2 3 3 4<br>3<br>4<br>5<br><strong>输出样例：</strong><br>3 4<br>5 5<br>-1 -1  </p></blockquote></blockquote><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>注意细节，照着板子做就行啦~</p><hr><p>二分其实不仅限于寻找数的范围，其更常用的是在特定条件下求最值的问题。 更常用的代码模板是这样的：</p><ol><li><p>区间分为[l,mid],[mid + 1, r]:</p><pre><code class="line-numbers language-cpp">int bsearch1(int l, int r)&#123;    int mid = l + r &gt;&gt; 1;    if(check(mid))r = mid;    else l = mid + 1;&#125;</code></pre></li><li><p>区间分为[l,mid -1],[mid,r]:</p><pre><code class="line-numbers language-cpp">int bsearch2(int l,int r)&#123;    int mid = l + r +1&gt;&gt; 1;    if(check(mid))l = mid;    else r = mid -1;&#125;</code></pre><hr><p>暂时先这么多吧。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序(Merge sort)</title>
      <link href="/2021/07/09/"/>
      <url>/2021/07/09/</url>
      
        <content type="html"><![CDATA[<h2 id="简介-Introduction"><a href="#简介-Introduction" class="headerlink" title="简介(Introduction)"></a>简介(Introduction)</h2><blockquote><blockquote><p>归并排序（Merge Sort）是建立在归并操作上的一种有效，<strong>稳定的</strong>排序算法，该算法是采用<strong>分治法</strong>（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p></blockquote></blockquote><h2 id="描述-Description"><a href="#描述-Description" class="headerlink" title="描述(Description)"></a>描述(Description)</h2><p>归并排序的核心思想是“分而治之”，把一个问题一步一步拆解为一个最简单的问题。</p><h2 id="示例-Example"><a href="#示例-Example" class="headerlink" title="示例(Example)"></a>示例(Example)</h2><p><img src="https://i.loli.net/2021/07/09/46cuGVwyNxEBFC8.jpg" alt="归并"></p><h2 id="代码实现-Code"><a href="#代码实现-Code" class="headerlink" title="代码实现(Code)"></a>代码实现(Code)</h2><pre><code class="line-numbers language-cpp">void merge_sort(int a[], int l , int r)&#123;  if(l &gt;= r)return;  int mid = l + r &gt;&gt; 1;  merge_sort(a, l, mid);//左递归处理  merge_sort(a, mid + 1, r);//右递归处理    int k = 0, i = l, j = mid + 1；  while(i &lt;= mid &amp;&amp; j &lt;= r)    if(a[i] &lt; a[j])t[k++] = a[i++];//数组作为临时储存空间    else t[k++] = a[j++];  while(i &lt;= mid)t[k++] = a[i++];  while(j &lt;= r)t[k++] = a[j++];//左右两者其中一个未遍历完成的直接把剩下整个接到数组后面  for(int i = l,j = 0; i &lt;= r ; i++, j++)  a[i] = t[j];//返回给a数组&#125;</code></pre><h2 id="性能分析-Analysis"><a href="#性能分析-Analysis" class="headerlink" title="性能分析(Analysis)"></a>性能分析(Analysis)</h2><p>归并排序平均时间复杂度为$O(nlogn)$,相比快排具有额外的空间复杂度$O(n)$。</p><hr><h2 id="应用：求逆序对的数量"><a href="#应用：求逆序对的数量" class="headerlink" title="应用：求逆序对的数量"></a>应用：求逆序对的数量</h2><blockquote><blockquote><p>给定一个长度为$n$的整数数列，请你计算数列中的逆序对的数量。<br>逆序对的定义如下：对于数列的第 $i$ 个和第 $j$ 个元素，如果满足 $i &lt; j $且 $a[i] &gt; a[j]$，则其为一个逆序对；否则不是。<br><strong>输入格式</strong><br>第一行包含整数$n$，表示数列的长度。<br>第二行包含 $n$ 个整数，表示整个数列。<br><strong>输出格式</strong><br>输出一个整数，表示逆序对的个数。<br><strong>数据范围</strong><br>$1≤n≤100000$<br><strong>输入样例：</strong><br>6<br>2 3 4 5 6 1<br><strong>输出样例：</strong><br>5</p></blockquote></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>受归并排序启发，对于每一段归并过程中添加一个记录答案的变量res。进行左右比较给临时数组存值时，<strong>res = mid - i +1</strong>，表示左边一直到mid的所有值都比当前的j指向的值大，构成逆序对。最后每段返回res即可。(ps:注意数据范围)</p>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序(Quick sort)</title>
      <link href="/2021/07/08/"/>
      <url>/2021/07/08/</url>
      
        <content type="html"><![CDATA[<h2 id="简介-Introduction"><a href="#简介-Introduction" class="headerlink" title="简介(Introduction)"></a>简介(Introduction)</h2><blockquote><p>快速排序由C. A. R. Hoare在1960年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p></blockquote><h2 id="描述-Description"><a href="#描述-Description" class="headerlink" title="描述(Description)"></a>描述(Description)</h2><p>快排的大致过程是对于一个无序序列，找到一个“基准数”，通过交换，使得序列分为两块，之后这两块再进行递归处理。基准数随便选，这里暂不考虑“基准数”选择的讲究。</p><h2 id="示例-Example"><a href="#示例-Example" class="headerlink" title="示例(Example)"></a>示例(Example)</h2><p><img src="https://i.loli.net/2021/07/09/zdV47rZ2OfvqjJ8.png" alt="快排"></p><h2 id="代码实现-Code"><a href="#代码实现-Code" class="headerlink" title="代码实现(Code)"></a>代码实现(Code)</h2><pre><code class="line-numbers language-cpp">void quick_sort(int a[], int l, int r)&#123;  if (l == r)  return ;  int flag = a[(l + r) / 2],i = l - 1, j = r + 1;  while(i &lt; j)  &#123;    while(a[++i] &lt; flag);    while(a[--j] &gt; flag);    if(i &lt; j)swap(a[i],a[j]);  &#125;  quick_sort(a,l,j);  quick_sort(a,j + 1,r);&#125;</code></pre><h2 id="性能分析-Analysis"><a href="#性能分析-Analysis" class="headerlink" title="性能分析(Analysis)"></a>性能分析(Analysis)</h2><p>快速排序在理想情况下的时间复杂度为$O(nlogn)$,在极端情况下时间复杂度为$O(n^2)$。</p><hr><h2 id="应用-快速选择"><a href="#应用-快速选择" class="headerlink" title="应用:快速选择"></a>应用:快速选择</h2><blockquote><blockquote><p>给定一个长度为n的整数数列，以及一个整数k，请用快速选择算法求出数列从小到大排序后的第k个数。<br><strong>输入格式</strong><br>第一行包含两个整数 n 和 k。<br>第二行包含 n 个整数（所有整数均在1~109范围内），表示整数数列。<br><strong>输出格式</strong><br>输出一个整数，表示数列的第k小数。<br><strong>数据范围</strong><br>1≤n≤100000,<br>1≤k≤n.<br><strong>输入样例：</strong><br>5 3<br>2 4 1 5 3<br><strong>输出样例：</strong><br>3</p></blockquote></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>如果单纯利用快排进行排序，时间复杂度就是$O(nlogn)$。但是本题可以利用快排的性质，<strong>只递归第k个数所在的那一半</strong>，把时间复杂度优化到$O(n)$。</p>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
