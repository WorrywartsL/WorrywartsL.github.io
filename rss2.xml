<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>L&#39;s Home</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Fri, 09 Jul 2021 03:20:59 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>归并排序(Merge sort)</title>
      <link>http://example.com/2021/07/09/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F(Merge%20sort)/</link>
      <guid>http://example.com/2021/07/09/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F(Merge%20sort)/</guid>
      <pubDate>Fri, 09 Jul 2021 02:07:26 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;简介-Introduction&quot;&gt;&lt;a href=&quot;#简介-Introduction&quot; class=&quot;headerlink&quot; title=&quot;简介(Introduction)&quot;&gt;&lt;/a&gt;简介(Introduction)&lt;/h2&gt;&lt;blockquote&gt;
&lt;block</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="简介-Introduction"><a href="#简介-Introduction" class="headerlink" title="简介(Introduction)"></a>简介(Introduction)</h2><blockquote><blockquote><p>归并排序（Merge Sort）是建立在归并操作上的一种有效，<strong>稳定的</strong>排序算法，该算法是采用<strong>分治法</strong>（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p></blockquote></blockquote><h2 id="描述-Description"><a href="#描述-Description" class="headerlink" title="描述(Description)"></a>描述(Description)</h2><p>归并排序的核心思想是“分而治之”，把一个问题一步一步拆解为一个最简单的问题。</p><h2 id="示例-Example"><a href="#示例-Example" class="headerlink" title="示例(Example)"></a>示例(Example)</h2><p><img src="https://i.loli.net/2021/07/09/46cuGVwyNxEBFC8.jpg" alt="示例"></p><h2 id="代码实现-Code"><a href="#代码实现-Code" class="headerlink" title="代码实现(Code)"></a>代码实现(Code)</h2><pre><code class="line-numbers language-cpp">void merge_sort(int a[], int l , int r)&#123;  if(l &gt;= r)return;  int mid = l + r &gt;&gt; 1;  merge_sort(a, l, mid);//左递归处理  merge_sort(a, mid + 1, r);//右递归处理    int k = 0, i = l, j = mid + 1；  while(i &lt;= mid &amp;&amp; j &lt;= r)    if(a[i] &lt; a[j])t[k++] = a[i++];//数组作为临时储存空间    else t[k++] = a[j++];  while(i &lt;= mid)t[k++] = a[i++];  while(j &lt;= r)t[k++] = a[j++];//左右两者其中一个未遍历完成的直接把剩下整个接到数组后面  for(int i = l,j = 0; i &lt;= r ; i++, j++)  a[i] = t[j];//返回给a数组&#125;</code></pre><h2 id="性能分析-Analysis"><a href="#性能分析-Analysis" class="headerlink" title="性能分析(Analysis)"></a>性能分析(Analysis)</h2><p>归并排序平均时间复杂度为$O(nlogn)$,相比快排具有额外的空间复杂度$O(n)$。</p><hr><h2 id="应用：求逆序对的数量"><a href="#应用：求逆序对的数量" class="headerlink" title="应用：求逆序对的数量"></a>应用：求逆序对的数量</h2><blockquote><blockquote><p>给定一个长度为$n$的整数数列，请你计算数列中的逆序对的数量。<br>逆序对的定义如下：对于数列的第 $i$ 个和第 $j$ 个元素，如果满足 $i &lt; j $且 $a[i] &gt; a[j]$，则其为一个逆序对；否则不是。<br><strong>输入格式</strong><br>第一行包含整数$n$，表示数列的长度。<br>第二行包含 $n$ 个整数，表示整个数列。<br><strong>输出格式</strong><br>输出一个整数，表示逆序对的个数。<br><strong>数据范围</strong><br>$1≤n≤100000$<br><strong>输入样例：</strong><br>6<br>2 3 4 5 6 1<br><strong>输出样例：</strong><br>5</p></blockquote></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>受归并排序启发，对于每一段归并过程中添加一个记录答案的变量res。进行左右比较给临时数组存值时，<strong>res = mid - i +1</strong>，表示左边一直到mid的所有值都比当前的j指向的值大，构成逆序对。最后每段返回res即可。(ps:注意数据范围)</p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/">归并排序</category>
      
      
      <comments>http://example.com/2021/07/09/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F(Merge%20sort)/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>快速排序(Quick sort)</title>
      <link>http://example.com/2021/07/08/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F(Quick%20sort)/</link>
      <guid>http://example.com/2021/07/08/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F(Quick%20sort)/</guid>
      <pubDate>Thu, 08 Jul 2021 14:26:32 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;简介-Introduction&quot;&gt;&lt;a href=&quot;#简介-Introduction&quot; class=&quot;headerlink&quot; title=&quot;简介(Introduction)&quot;&gt;&lt;/a&gt;简介(Introduction)&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;快速排</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="简介-Introduction"><a href="#简介-Introduction" class="headerlink" title="简介(Introduction)"></a>简介(Introduction)</h2><blockquote><p>快速排序由C. A. R. Hoare在1960年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p></blockquote><h2 id="描述-Description"><a href="#描述-Description" class="headerlink" title="描述(Description)"></a>描述(Description)</h2><p>快排的大致过程是对于一个无序序列，找到一个“基准数”，通过交换，使得序列分为两块，之后这两块再进行递归处理。基准数随便选，这里暂不考虑“基准数”选择的讲究。</p><h2 id="示例-Example"><a href="#示例-Example" class="headerlink" title="示例(Example)"></a>示例(Example)</h2><p><img src="https://i.loli.net/2021/07/09/zdV47rZ2OfvqjJ8.png" alt="快排"></p><h2 id="代码实现-Code"><a href="#代码实现-Code" class="headerlink" title="代码实现(Code)"></a>代码实现(Code)</h2><pre><code class="line-numbers language-cpp">void quick_sort(int a[], int l, int r)&#123;  if (l == r)  return ;  int flag = a[(l + r) / 2],i = l - 1, j = r + 1;  while(i &lt; j)  &#123;    while(a[++i] &lt; flag);    while(a[--j] &gt; flag);    if(i &lt; j)swap(a[i],a[j]);  &#125;  quick_sort(a,l,j);  quick_sort(a,j + 1,r);&#125;</code></pre><h2 id="性能分析-Analysis"><a href="#性能分析-Analysis" class="headerlink" title="性能分析(Analysis)"></a>性能分析(Analysis)</h2><p>快速排序在理想情况下的时间复杂度为$O(nlogn)$,在极端情况下时间复杂度为$O(n^2)$。</p><hr><h2 id="应用-快速选择"><a href="#应用-快速选择" class="headerlink" title="应用:快速选择"></a>应用:快速选择</h2><blockquote><blockquote><p>给定一个长度为n的整数数列，以及一个整数k，请用快速选择算法求出数列从小到大排序后的第k个数。<br><strong>输入格式</strong><br>第一行包含两个整数 n 和 k。<br>第二行包含 n 个整数（所有整数均在1~109范围内），表示整数数列。<br><strong>输出格式</strong><br>输出一个整数，表示数列的第k小数。<br><strong>数据范围</strong><br>1≤n≤100000,<br>1≤k≤n.<br><strong>输入样例：</strong><br>5 3<br>2 4 1 5 3<br><strong>输出样例：</strong><br>3</p></blockquote></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>如果单纯利用快排进行排序，时间复杂度就是$O(nlogn)$。但是本题可以利用快排的性质，<strong>只递归第k个数所在的那一半</strong>，把时间复杂度优化到$O(n)$。</p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/">快速排序</category>
      
      
      <comments>http://example.com/2021/07/08/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F(Quick%20sort)/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
